diff -ruN src/eap_peer/eap_aka.c src/eap_peer/eap_aka.c
--- src/eap_peer/eap_aka.c	2013-01-12 16:42:53.000000000 +0100
+++ src/eap_peer/eap_aka.c	2016-07-19 08:27:52.266681561 +0200
@@ -535,7 +535,7 @@
 	wpa_printf(MSG_DEBUG, "Generating EAP-AKA Challenge (id=%d)", id);
 	msg = eap_sim_msg_init(EAP_CODE_RESPONSE, id, data->eap_method,
 			       EAP_AKA_SUBTYPE_CHALLENGE);
-	wpa_printf(MSG_DEBUG, "   AT_RES");
+	wpa_printf(MSG_DEBUG, "   AT_RES: %zu", data->res_len);
 	eap_sim_msg_add(msg, EAP_SIM_AT_RES, data->res_len * 8,
 			data->res, data->res_len);
 	eap_aka_add_checkcode(data, msg);
diff -ruN src/eap_peer/eap_config.h src/eap_peer/eap_config.h
--- src/eap_peer/eap_config.h	2013-01-12 16:42:53.000000000 +0100
+++ src/eap_peer/eap_config.h	2016-07-19 08:27:52.266681561 +0200
@@ -634,6 +634,13 @@
 	 *         password field is the name of that external entry
 	 */
 	u32 flags;
+
+	/**
+	* IMSI and MNC length used by AKA/SMS EAO authentication
+	*/
+    char* imsi;
+
+    int mnc_len;
 };


diff -ruN src/eap_peer/eap_sim.c src/eap_peer/eap_sim.c
--- src/eap_peer/eap_sim.c	2013-01-12 16:42:53.000000000 +0100
+++ src/eap_peer/eap_sim.c	2016-07-19 08:27:52.266681561 +0200
@@ -162,7 +162,7 @@
 		    (data->num_chal > 2 &&
 		     scard_gsm_auth(sm->scard_ctx, data->rand[2],
 				    data->sres[2], data->kc[2]))) {
-			wpa_printf(MSG_DEBUG, "EAP-SIM: GSM SIM "
+			wpa_printf(MSG_ERROR, "EAP-SIM: GSM SIM "
 				   "authentication could not be completed");
 			return -1;
 		}
@@ -177,7 +177,7 @@
 		wpa_printf(MSG_DEBUG, "EAP-SIM: Use internal GSM-Milenage "
 			   "implementation for authentication");
 		if (conf->password_len < 65) {
-			wpa_printf(MSG_DEBUG, "EAP-SIM: invalid GSM-Milenage "
+			wpa_printf(MSG_ERROR, "EAP-SIM: invalid GSM-Milenage "
 				   "password");
 			return -1;
 		}
@@ -195,7 +195,7 @@
 		for (i = 0; i < data->num_chal; i++) {
 			if (gsm_milenage(opc, k, data->rand[i],
 					 data->sres[i], data->kc[i])) {
-				wpa_printf(MSG_DEBUG, "EAP-SIM: "
+				wpa_printf(MSG_ERROR, "EAP-SIM: "
 					   "GSM-Milenage authentication "
 					   "could not be completed");
 				return -1;
diff -ruN src/radius/radius.c src/radius/radius.c
--- src/radius/radius.c	2013-01-12 16:42:53.000000000 +0100
+++ src/radius/radius.c	2016-07-19 10:11:02.763895993 +0200
@@ -14,6 +14,43 @@
 #include "crypto/crypto.h"
 #include "radius.h"

+#ifndef strlcat
+/*
+ * Appends src to string dst of size siz (unlike strncat, siz is the
+ * full size of dst, not space left).  At most siz-1 characters
+ * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).
+ * Returns strlen(src) + MIN(siz, strlen(initial dst)).
+ * If retval >= siz, truncation occurred.
+ */
+size_t
+strlcat(char *dst, const char *src, size_t siz)
+{
+	char *d = dst;
+	const char *s = src;
+	size_t n = siz;
+	size_t dlen;
+
+	/* Find the end of dst and adjust bytes left but don't go past end */
+	while (n-- != 0 && *d != '\0')
+		d++;
+	dlen = d - dst;
+	n = siz - dlen;
+
+	if (n == 0)
+		return(dlen + strlen(s));
+	while (*s != '\0') {
+		if (n != 1) {
+			*d++ = *s;
+			n--;
+		}
+		s++;
+	}
+	*d = '\0';
+
+	return(dlen + (s - src));	/* count does not include NUL */
+}
+#endif
+

 /**
  * struct radius_msg - RADIUS message structure for new and parsed messages
@@ -249,12 +286,23 @@
 }


-static void print_char(char c)
+static void fmt_char(char c, char* str, size_t len)
 {
 	if (c >= 32 && c < 127)
-		printf("%c", c);
+	{
+	    char tmp[2];
+	    tmp[sizeof(tmp)-1] = '\0';
+	    os_snprintf(tmp,  sizeof(tmp), "%c", c);
+	    strlcat(str, tmp, len);
+	}
 	else
-		printf("<%02x>", c);
+	{
+	    char tmp[5];
+	    tmp[sizeof(tmp)-1] = '\0';
+	    os_snprintf(tmp,  sizeof(tmp), "<%02x>", c);
+	    strlcat(str, tmp, len);
+	}
+
 }


@@ -266,7 +314,7 @@

 	attr = radius_get_attr_type(hdr->type);

-	printf("   Attribute %d (%s) length=%d\n",
+	wpa_printf(MSG_DEBUG, "   Attribute %d (%s) length=%d",
 	       hdr->type, attr ? attr->name : "?Unknown?", hdr->length);

 	if (attr == NULL || hdr->length < sizeof(struct radius_attr_hdr))
@@ -277,19 +325,25 @@

 	switch (attr->data_type) {
 	case RADIUS_ATTR_TEXT:
-		printf("      Value: '");
+    {
+        const size_t value_str_len = len * 4 + 1;
+        char* value_str = (char*)os_zalloc(value_str_len);
 		for (i = 0; i < len; i++)
-			print_char(pos[i]);
-		printf("'\n");
+        {
+			char c = pos[i];
+			fmt_char(c, value_str, value_str_len);
+        }
+		wpa_printf(MSG_DEBUG, "      Value: '%s'", value_str);
+        free(value_str);
 		break;
-
+    }
 	case RADIUS_ATTR_IP:
 		if (len == 4) {
 			struct in_addr addr;
 			os_memcpy(&addr, pos, 4);
-			printf("      Value: %s\n", inet_ntoa(addr));
+			wpa_printf(MSG_DEBUG, "      Value: %s", inet_ntoa(addr));
 		} else
-			printf("      Invalid IP address length %d\n", len);
+			wpa_printf(MSG_DEBUG, "      Invalid IP address length %d", len);
 		break;

 #ifdef CONFIG_IPV6
@@ -299,25 +353,34 @@
 			const char *atxt;
 			struct in6_addr *addr = (struct in6_addr *) pos;
 			atxt = inet_ntop(AF_INET6, addr, buf, sizeof(buf));
-			printf("      Value: %s\n", atxt ? atxt : "?");
+			wpa_printf(MSG_DEBUG, "      Value: %s", atxt ? atxt : "?");
 		} else
-			printf("      Invalid IPv6 address length %d\n", len);
+			wpa_printf(MSG_DEBUG, "      Invalid IPv6 address length %d", len);
 		break;
 #endif /* CONFIG_IPV6 */

 	case RADIUS_ATTR_HEXDUMP:
 	case RADIUS_ATTR_UNDIST:
-		printf("      Value:");
+    {
+        const size_t value_str_len = len * 3 + 1;
+        char* value_str = (char*)os_zalloc(value_str_len);
 		for (i = 0; i < len; i++)
-			printf(" %02x", pos[i]);
-		printf("\n");
+        {
+			unsigned char c = pos[i];
+            char tmp[4];
+            tmp[sizeof(tmp)-1] = '\0';
+            os_snprintf(tmp, sizeof(tmp), i == len -1 ? "%02x" : "%02x ", c);
+            strlcat(value_str, tmp, value_str_len);
+        }
+		wpa_printf(MSG_DEBUG, "      Value: '%s'", value_str);
+        free(value_str);
 		break;
-
+    }
 	case RADIUS_ATTR_INT32:
 		if (len == 4)
-			printf("      Value: %u\n", WPA_GET_BE32(pos));
+			wpa_printf(MSG_DEBUG, "      Value: %u", WPA_GET_BE32(pos));
 		else
-			printf("      Invalid INT32 length %d\n", len);
+			wpa_printf(MSG_DEBUG, "      Invalid INT32 length %d", len);
 		break;

 	default:
@@ -330,7 +393,7 @@
 {
 	size_t i;

-	printf("RADIUS message: code=%d (%s) identifier=%d length=%d\n",
+	wpa_printf(MSG_INFO, "RADIUS message: code=%d (%s) identifier=%d length=%d",
 	       msg->hdr->code, radius_code_string(msg->hdr->code),
 	       msg->hdr->identifier, be_to_host16(msg->hdr->length));

@@ -384,7 +447,7 @@
 	attr = radius_msg_add_attr(msg, RADIUS_ATTR_MESSAGE_AUTHENTICATOR,
 				   auth, MD5_MAC_LEN);
 	if (attr == NULL) {
-		printf("WARNING: Could not add Message-Authenticator\n");
+		wpa_printf(MSG_WARNING, "WARNING: Could not add Message-Authenticator");
 		return -1;
 	}
 	msg->hdr->length = host_to_be16(wpabuf_len(msg->buf));
@@ -585,7 +648,7 @@
 	struct radius_attr_hdr *attr;

 	if (data_len > RADIUS_MAX_ATTR_LEN) {
-		printf("radius_msg_add_attr: too long attribute (%lu bytes)\n",
+		wpa_printf(MSG_WARNING, "radius_msg_add_attr: too long attribute (%lu bytes)",
 		       (unsigned long) data_len);
 		return NULL;
 	}
@@ -635,7 +698,7 @@

 	msg_len = be_to_host16(hdr->length);
 	if (msg_len < sizeof(*hdr) || msg_len > len) {
-		wpa_printf(MSG_INFO, "RADIUS: Invalid message length");
+		wpa_printf(MSG_WARNING, "RADIUS: Invalid message length");
 		return NULL;
 	}

@@ -756,8 +819,8 @@
 		tmp = radius_get_attr_hdr(msg, i);
 		if (tmp->type == RADIUS_ATTR_MESSAGE_AUTHENTICATOR) {
 			if (attr != NULL) {
-				printf("Multiple Message-Authenticator "
-				       "attributes in RADIUS message\n");
+				wpa_printf(MSG_DEBUG, "Multiple Message-Authenticator "
+				       "attributes in RADIUS message");
 				return 1;
 			}
 			attr = tmp;
@@ -765,7 +828,7 @@
 	}

 	if (attr == NULL) {
-		printf("No Message-Authenticator attribute found\n");
+		wpa_printf(MSG_WARNING, "No Message-Authenticator attribute found");
 		return 1;
 	}

@@ -786,7 +849,7 @@
 	}

 	if (os_memcmp(orig, auth, MD5_MAC_LEN) != 0) {
-		printf("Invalid Message-Authenticator!\n");
+		wpa_printf(MSG_WARNING, "Invalid Message-Authenticator!");
 		return 1;
 	}

@@ -802,7 +865,7 @@
 	u8 hash[MD5_MAC_LEN];

 	if (sent_msg == NULL) {
-		printf("No matching Access-Request message found\n");
+		wpa_printf(MSG_WARNING, "No matching Access-Request message found");
 		return 1;
 	}

@@ -823,7 +886,7 @@
 	len[3] = secret_len;
 	md5_vector(4, addr, len, hash);
 	if (os_memcmp(hash, msg->hdr->authenticator, MD5_MAC_LEN) != 0) {
-		printf("Response Authenticator invalid!\n");
+		wpa_printf(MSG_WARNING, "Response Authenticator invalid!");
 		return 1;
 	}

@@ -962,7 +1025,7 @@
 	pos = key + 2;
 	left = len - 2;
 	if (left % 16) {
-		printf("Invalid ms key len %lu\n", (unsigned long) left);
+		wpa_printf(MSG_WARNING, "Invalid ms key len %lu", (unsigned long) left);
 		return NULL;
 	}

@@ -996,7 +1059,7 @@
 	}

 	if (plain[0] == 0 || plain[0] > plen - 1) {
-		printf("Failed to decrypt MPPE key\n");
+		wpa_printf(MSG_WARNING, "Failed to decrypt MPPE key");
 		os_free(plain);
 		return NULL;
 	}
diff -ruN src/utils/pcsc_funcs.c src/utils/pcsc_funcs.c
--- src/utils/pcsc_funcs.c	2013-01-12 16:42:53.000000000 +0100
+++ src/utils/pcsc_funcs.c	2016-07-19 09:54:18.272025054 +0200
@@ -11,6 +11,8 @@
  */

 #include "includes.h"
+
+#ifndef PCSC_RELAY_FUNCS // "real" smartcard communication
 #include <winscard.h>

 #include "common.h"
@@ -179,7 +181,6 @@
 (*dll_SCardEndTransaction)(IN SCARDHANDLE hCard, IN DWORD dwDisposition);
 #define SCardEndTransaction dll_SCardEndTransaction

-
 static int mingw_load_symbols(void)
 {
 	char *sym;
@@ -240,7 +241,7 @@

 #endif /* __MINGW32_VERSION */

-
+static int scard_get_pin_retry_counter(struct scard_data *scard);
 static int _scard_select_file(struct scard_data *scard, unsigned short file_id,
 			      unsigned char *buf, size_t *buf_len,
 			      sim_types sim_type, unsigned char *aid,
@@ -1033,7 +1034,7 @@
 }


-int scard_get_pin_retry_counter(struct scard_data *scard)
+static int scard_get_pin_retry_counter(struct scard_data *scard)
 {
 	long ret;
 	unsigned char resp[3];
@@ -1425,3 +1426,478 @@
 {
 	return scard->sim_type == SCARD_USIM;
 }
+
+
+#else
+///////////////////////////////////////////////////////////////////
+// smartcard functions relayed to the caller
+///////////////////////////////////////////////////////////////////
+
+#include "common.h"
+#include "pcsc_funcs.h"
+#include "eap_common/eap_sim_common.h"
+
+#include <assert.h>
+#include <ctype.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netdb.h>
+#include <errno.h>
+
+// Communicaiton with KT user consists of two phases
+// 1. KT user sends IMSI, card type and MMC length
+// 2. radeapclient contacts RADIUS with these settings
+// 3. radeapclient queries user for a response (response fields depends on card type) given a challenge received from RADIUS
+// 4. radeapclient contacts RADIUS server with the response received from the user
+typedef enum { SCARD_GSM_SIM, SCARD_USIM } sim_types;
+
+struct scard_data {
+	sim_types sim_type;
+    char imsi_str[21];
+	int mnc_len;
+	int caller_sockfd;
+    int32_t challenge_code;
+};
+
+static const char* rad_eap_client_radeapp_header = "RADEAPP";
+
+
+#ifndef strlcpy
+static size_t strlcpy(char* dst, const char* src, size_t siz)
+{
+    char* d = dst;
+    const char* s = src;
+    size_t n = siz;
+
+    /* Copy as many bytes as will fit */
+    if (n != 0) {
+        while (--n != 0) {
+            if ((*d++ = *s++) == '\0')
+                break;
+        }
+    }
+
+    /* Not enough room in dst, add NUL and traverse rest of src */
+    if (n == 0) {
+        if (siz != 0)
+            *d = '\0';		/* NUL-terminate dst */
+        while (*s++)
+            ;
+    }
+
+    return(s - src - 1);	/* count does not include NUL */
+}
+#endif
+
+// Protocol message format:
+// RADEAPP<code-4-bytes>[<data-size-4-bytes><data>]
+// where codes are defined in radeapclient.h
+
+int scard_send_code_with_data(int sockfd, int32_t code, const void* data, int32_t data_len)
+{
+    if (sockfd == -1)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: Connection to the caller is not setup");
+        return -1;
+    }
+
+    const size_t radeapp_header_len = strlen(rad_eap_client_radeapp_header);
+    const size_t packet_len = radeapp_header_len + sizeof(code) + sizeof(data_len) + data_len;
+    char* packet = (char*)malloc(packet_len);
+    char* ppacket = packet;
+
+    // add header
+    memcpy(ppacket, rad_eap_client_radeapp_header, radeapp_header_len);
+    ppacket += radeapp_header_len;
+
+    // add code
+    memcpy(ppacket, &code, sizeof(code));
+    ppacket += sizeof(code);
+
+    // add data
+    memcpy(ppacket, &data_len, sizeof(data_len));
+    ppacket += sizeof(data_len);
+    if (data_len > 0)
+    {
+        memcpy(ppacket, data, data_len);
+    }
+
+    size_t bytes_remain = packet_len;
+    ppacket = packet;
+    while (bytes_remain > 0)
+    {
+        int tx_bytes = send(sockfd, ppacket, bytes_remain, 0);
+        if (tx_bytes < 0)
+        {
+            wpa_printf(MSG_ERROR, "SCARD RELAY: send(2) failed: %s", strerror(errno));
+            free(packet);
+            return -1;
+        }
+        assert(tx_bytes <= bytes_remain);
+        ppacket += tx_bytes;
+        bytes_remain -= tx_bytes;
+    }
+
+    free(packet);
+    wpa_printf(MSG_INFO, "SCARD RELAY: Sent packet with code %d and data length %d to the caller", code, data_len);
+    return 0;
+}
+
+static int scard_receive_buf(int sockfd, unsigned char* buf, size_t len)
+{
+    if (sockfd == -1)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: Connection to the caller is not setup");
+        return -1;
+    }
+    if (!len)
+    {
+        return 0;
+    }
+    if (!buf)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: recv buffer is NULL\n");
+        return -1;
+    }
+
+    size_t bytes_remain = len;
+    unsigned char* buf_ptr = buf;
+    while (bytes_remain > 0)
+    {
+        size_t rx_bytes = recv(sockfd, buf_ptr, bytes_remain, 0);
+        if (rx_bytes == 0)
+        {
+            wpa_printf(MSG_ERROR, "SCARD RELAY: The connection with the caller has been gracefully closed while waiting for the data");
+            return -1;
+        }
+        if (rx_bytes == (size_t)-1)
+        {
+            wpa_printf(MSG_ERROR, "SCARD RELAY: recv(2) failed. %s", strerror(errno));
+            return -1;
+        }
+        assert(rx_bytes <= bytes_remain);
+        buf_ptr += rx_bytes;
+        bytes_remain -= rx_bytes;
+    }
+    return 0;
+}
+
+// if actual_response_len is not NULL, we expect response length <= response_len and *actual_response_len is set to the actual response length
+// otherwise, when actual_response_len is NULL, we expect response length to be equal to response_len
+static int scard_receive_response(int sockfd, unsigned char* response, size_t response_len, size_t* actual_response_len)
+{
+    const size_t radeapp_header_len = strlen(rad_eap_client_radeapp_header);
+    unsigned char* header = malloc(radeapp_header_len);
+    if (scard_receive_buf(sockfd, header, radeapp_header_len))
+    {
+        free(header);
+        return -1;
+    }
+    if (memcmp(header, rad_eap_client_radeapp_header, radeapp_header_len))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: No %s header found in the incoming message", rad_eap_client_radeapp_header);
+        free(header);
+        return -1;
+
+    }
+    free(header);
+
+    unsigned char code[sizeof(int32_t)];
+    if (scard_receive_buf(sockfd, code, sizeof(code)))
+    {
+        return -1;
+    }
+    int32_t received_response_len = 0;
+    memcpy(&received_response_len, code, sizeof(received_response_len));
+
+    if (received_response_len > 0)
+    {
+        if (actual_response_len)
+        {
+            if (response_len < received_response_len)
+            {
+                wpa_printf(MSG_ERROR, "SCARD RELAY: Expected response size %zu is too small to hold received response of size %d", response_len, received_response_len);
+                return -1;
+            }
+            *actual_response_len = received_response_len;
+        }
+        else
+        {
+            if (response_len != received_response_len)
+            {
+                wpa_printf(MSG_ERROR, "SCARD RELAY: Expected response size %zu differs from the received response size %d", response_len, received_response_len);
+                return -1;
+            }
+        }
+
+        if (scard_receive_buf(sockfd, response, received_response_len))
+        {
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+struct scard_data * scard_init(scard_sim_type sim_type, const char *imsi_str, int mnc_len, int caller_sockfd, int32_t challenge_code)
+{
+	if (!imsi_str || !strlen(imsi_str))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: cannot initialize SIM card, IMSI is not set");
+		return NULL;
+    }
+    if (caller_sockfd == -1)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: cannot initialize SIM card, caller connection is not established");
+		return NULL;
+    }
+
+    wpa_printf(MSG_INFO, "SCARD RELAY: Initialize with %s method, IMSI %s, MNC length %d",
+                         sim_type == SCARD_TRY_BOTH ? "SIM and UMTS"
+                         : sim_type == SCARD_USIM_ONLY ? "UMTS"
+                         : sim_type == SCARD_GSM_SIM_ONLY ? "GSM"
+                         : "UNKNOWN",
+                         imsi_str, mnc_len);
+
+	struct scard_data *scard = os_zalloc(sizeof(*scard));
+	if (!scard)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: cannot initialize SIM card, cannot allocate memory");
+		return NULL;
+    }
+    if (strlcpy(scard->imsi_str, imsi_str, sizeof(scard->imsi_str)) >= sizeof(scard->imsi_str))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: cannot initialize SIM card, IMSI (%s) is too long", imsi_str);
+        os_free(scard);
+		return NULL;
+    }
+
+    switch (sim_type)
+    {
+        case SCARD_GSM_SIM_ONLY:
+            scard->sim_type = SCARD_GSM_SIM;
+            break;
+        case SCARD_USIM_ONLY:
+            scard->sim_type = SCARD_USIM;
+            break;
+        case SCARD_TRY_BOTH:
+        default:
+            wpa_printf(MSG_ERROR, "SCARD INIT: either GSM or USIM SIM card type should be supplied");
+            os_free(scard);
+            return NULL;
+    }
+    scard->mnc_len = mnc_len;
+    scard->caller_sockfd = caller_sockfd;
+    scard->challenge_code = challenge_code;
+
+	return scard;
+}
+
+void scard_deinit(struct scard_data *scard)
+{
+	if (!scard )
+		return;
+
+	wpa_printf(MSG_DEBUG, "SCARD RELAY: deinitializing smart card interface");
+	os_free(scard);
+}
+
+int scard_set_pin(struct scard_data *scard, const char *pin)
+{
+    // noop
+	return 0;
+}
+
+/**
+ * scard_get_imsi - Read IMSI from SIM/USIM card
+ * @scard: Pointer to private data from scard_init()
+ * @imsi: Buffer for IMSI
+ * @len: Length of imsi buffer; set to IMSI length on success
+ * Returns: 0 on success, < 0 on error if reading IMSI file fails.
+ */
+int scard_get_imsi(struct scard_data *scard, char *imsi, size_t *len)
+{
+	wpa_printf(MSG_INFO, "SCARD RELAY: getting IMSI");
+
+    if (!scard || !imsi || !len)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: invalid arguments passed to scard_get_imsi()");
+        return -1;
+    }
+
+    const size_t imsi_len = strlen(scard->imsi_str);
+    if (*len < imsi_len)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: cannot read IMSI, too short IMSI buffer. Actual: %zu. Expected: at least %zu", *len, imsi_len);
+        return -1;
+    }
+    memcpy(imsi, scard->imsi_str, imsi_len);
+    *len = imsi_len;
+
+	return 0;
+}
+
+int scard_get_mnc_len(struct scard_data *scard)
+{
+    wpa_printf(MSG_INFO, "SCARD RELAY: Get mnc length");
+    if (!scard)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: invalid arguments passed to scard_get_mnc_len()");
+        return -1;
+    }
+    return scard->mnc_len;
+}
+
+/**
+ * scard_gsm_auth - Run GSM authentication command on SIM card and on success retrieve secret response and session key
+ * @scard: Pointer to private data from scard_init()
+ * @_rand: 16-byte RAND value from HLR/AuC
+ * @sres[out]: 4-byte buffer for SRES (secret response)
+ * @kc [out]: 8-byte buffer for Kc (session key)
+ * Returns: 0 on success, error otherwise
+ *
+ * This function performs GSM authentication using SIM/USIM card and the
+ * provided RAND value from HLR/AuC. If authentication command can be completed
+ * successfully, SRES and Kc values will be written into sres and kc buffers.
+ */
+int scard_gsm_auth(struct scard_data *scard, const unsigned char *_rand,
+		   unsigned char *sres, unsigned char *kc)
+{
+    wpa_printf(MSG_INFO, "SCARD RELAY: GSM authentication request");
+
+
+	if (!scard || !_rand || !sres || !kc)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: invalid arguments passed to scard_gsm_auth()");
+		return -1;
+    }
+
+	wpa_hexdump(MSG_INFO, "SCARD RELAY: GSM authentication - RAND", _rand, GSM_RAND_LEN);
+
+    // Send RAND challenge as name\0value
+    static const char challenge_name[] = "GSM RANDOM";
+    unsigned char challenge[sizeof(challenge_name) + GSM_RAND_LEN];
+    memcpy(challenge, challenge_name, sizeof(challenge_name));
+    memcpy(challenge + sizeof(challenge_name), _rand, GSM_RAND_LEN);
+    if (scard_send_code_with_data(scard->caller_sockfd, scard->challenge_code, challenge, sizeof(challenge)))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR sending GSM authentication request");
+        return -1;
+    }
+    wpa_printf(MSG_INFO, "SCARD RELAY: SIM challenge sent, waiting for the response");
+
+    // Wait for response
+    if (scard_receive_response(scard->caller_sockfd, sres, EAP_SIM_SRES_LEN, NULL))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR receiving GSM SRES authentication response");
+        return -1;
+    }
+    if (scard_receive_response(scard->caller_sockfd, kc, EAP_SIM_KC_LEN, NULL))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR receiving GSM KC authentication response");
+        return -1;
+    }
+
+    wpa_printf(MSG_INFO, "SCARD RELAY: GSM response received");
+	wpa_hexdump(MSG_INFO, "SCARD RELAY: GSM auth - SRES", sres, EAP_SIM_SRES_LEN);
+	wpa_hexdump(MSG_INFO, "SCARD RELAY: GSM auth - Kc", kc, EAP_SIM_KC_LEN);
+
+	return 0;
+}
+
+
+/**
+ * scard_umts_auth - Run UMTS authentication command on USIM card
+ * @scard: Pointer to private data from scard_init()
+ * @_rand: 16-byte RAND value from HLR/AuC
+ * @autn: 16-byte AUTN value from HLR/AuC
+ * @res: 16-byte buffer for RES
+ * @res_len: Variable that will be set to RES length
+ * @ik: 16-byte buffer for IK
+ * @ck: 16-byte buffer for CK
+ * @auts: 14-byte buffer for AUTS
+ * Returns: 0 on success, -1 on failure, or -2 if USIM reports synchronization
+ * failure
+ *
+ * This function performs AKA authentication using USIM card and the provided
+ * RAND and AUTN values from HLR/AuC. If authentication command can be
+ * completed successfully, RES, IK, and CK values will be written into provided
+ * buffers and res_len is set to length of received RES value. If USIM reports
+ * synchronization failure, the received AUTS value will be written into auts
+ * buffer. In this case, RES, IK, and CK are not valid.
+ */
+int scard_umts_auth(struct scard_data *scard, const unsigned char *_rand,
+		    const unsigned char *autn,
+		    unsigned char *res, size_t *res_len,
+		    unsigned char *ik, unsigned char *ck, unsigned char *auts)
+{
+    wpa_printf(MSG_INFO, "SCARD RELAY: UMTS (AKA) authentication request");
+
+	if (!scard || !_rand || !autn || !res || !res_len || !ik || !ck || !auts)
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: invalid arguments passed to scard_umts_auth()");
+		return -1;
+    }
+
+	if (scard->sim_type == SCARD_GSM_SIM) {
+		wpa_printf(MSG_ERROR, "SCARD: Non-USIM card - cannot do UMTS auth");
+		return -1;
+	}
+
+	wpa_hexdump(MSG_INFO, "SCARD: UMTS auth - RAND", _rand, EAP_AKA_RAND_LEN);
+	wpa_hexdump(MSG_INFO, "SCARD: UMTS auth - AUTN", autn, EAP_AKA_AUTN_LEN);
+
+    // Send RAND challenge as name\0value
+    static const char rand_challenge_name[] = "UMTS RANDOM";
+    unsigned char rand_challenge[sizeof(rand_challenge_name) + EAP_AKA_RAND_LEN];
+    memcpy(rand_challenge, rand_challenge_name, sizeof(rand_challenge_name));
+    memcpy(rand_challenge + sizeof(rand_challenge_name), _rand, EAP_AKA_RAND_LEN);
+    if (scard_send_code_with_data(scard->caller_sockfd, scard->challenge_code, rand_challenge, sizeof(rand_challenge)))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR sending UMTS RAND authentication request");
+        return -1;
+    }
+
+    // Send AUTN challenge as name\0value
+    static const char autn_challenge_name[] = "UMTS AUTN";
+    unsigned char autn_challenge[sizeof(autn_challenge_name) + EAP_AKA_AUTN_LEN];
+    memcpy(autn_challenge, autn_challenge_name, sizeof(autn_challenge_name));
+    memcpy(autn_challenge + sizeof(autn_challenge_name), autn, EAP_AKA_AUTN_LEN);
+    if (scard_send_code_with_data(scard->caller_sockfd, scard->challenge_code, autn_challenge, sizeof(autn_challenge)))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR sending UMTS AUTN authentication request");
+        return -1;
+    }
+
+    wpa_printf(MSG_INFO, "SCARD RELAY: UMTS challenge sent, waiting for the response");
+
+    if (scard_receive_response(scard->caller_sockfd, res, EAP_AKA_RES_MAX_LEN, res_len))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR receiving UMTS RES authentication response");
+        return -1;
+    }
+    if (scard_receive_response(scard->caller_sockfd, ik, EAP_AKA_IK_LEN, NULL))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR receiving UMTS IK authentication response");
+        return -1;
+    }
+    if (scard_receive_response(scard->caller_sockfd, ck, EAP_AKA_CK_LEN, NULL))
+    {
+        wpa_printf(MSG_ERROR, "SCARD RELAY: ERROR receiving UMTS CK authentication response");
+        return -1;
+    }
+    wpa_printf(MSG_INFO, "SCARD RELAY: UMTS response received");
+    wpa_hexdump(MSG_INFO, "SCARD RELAY: RES", res, *res_len);
+    wpa_hexdump(MSG_INFO, "SCARD RELAY: IK", ik, EAP_AKA_IK_LEN);
+    wpa_hexdump(MSG_INFO, "SCARD RELAY: CK", ck, EAP_AKA_CK_LEN);
+
+    return 0;
+}
+
+int scard_supports_umts(struct scard_data *scard)
+{
+    return scard->sim_type == SCARD_USIM;
+}
+
+#endif
diff -ruN src/utils/pcsc_funcs.h src/utils/pcsc_funcs.h
--- src/utils/pcsc_funcs.h	2013-01-12 16:42:53.000000000 +0100
+++ src/utils/pcsc_funcs.h	2016-07-19 08:27:52.290680970 +0200
@@ -9,6 +9,8 @@
 #ifndef PCSC_FUNCS_H
 #define PCSC_FUNCS_H

+#include <stdint.h>
+
 typedef enum {
 	SCARD_GSM_SIM_ONLY,
 	SCARD_USIM_ONLY,
@@ -17,7 +19,14 @@


 #ifdef PCSC_FUNCS
+#ifdef PCSC_RELAY_FUNCS
+struct scard_data * scard_init(scard_sim_type sim_type, const char *imsi_str, int mnc_len, int caller_sockfd, int32_t challenge_code);
+
+// send packet as <code><data-len><data> to the connected socket
+int scard_send_code_with_data(int sockfd, int32_t code, const void* data, int32_t data_len);
+#else
 struct scard_data * scard_init(scard_sim_type sim_type, const char *reader);
+#endif
 void scard_deinit(struct scard_data *scard);

 int scard_set_pin(struct scard_data *scard, const char *pin);
@@ -29,7 +38,6 @@
 		    const unsigned char *autn,
 		    unsigned char *res, size_t *res_len,
 		    unsigned char *ik, unsigned char *ck, unsigned char *auts);
-int scard_get_pin_retry_counter(struct scard_data *scard);
 int scard_supports_umts(struct scard_data *scard);

 #else /* PCSC_FUNCS */
@@ -41,7 +49,6 @@
 #define scard_get_mnc_len(s) -1
 #define scard_gsm_auth(s, r, s2, k) -1
 #define scard_umts_auth(s, r, a, r2, rl, i, c, a2) -1
-#define scard_get_pin_retry_counter(s) -1
 #define scard_supports_umts(s) 0

 #endif /* PCSC_FUNCS */
diff -ruN src/utils/wpa_debug.c src/utils/wpa_debug.c
--- src/utils/wpa_debug.c	2013-01-12 16:42:53.000000000 +0100
+++ src/utils/wpa_debug.c	2016-07-19 09:39:48.384505128 +0200
@@ -9,6 +9,7 @@
 #include "includes.h"

 #include "common.h"
+#include <time.h>

 #ifdef CONFIG_DEBUG_SYSLOG
 #include <syslog.h>
@@ -71,13 +72,16 @@
 		return;

 	os_get_time(&tv);
+	struct tm* timeinfo = localtime((time_t*)&tv.sec);
+	char time_buffer [80];
+	strftime (time_buffer,sizeof(time_buffer),"%Y-%b-%d %H:%M:%S",timeinfo);
+	unsigned int msecs = tv.usec / 1000;
 #ifdef CONFIG_DEBUG_FILE
 	if (out_file) {
-		fprintf(out_file, "%ld.%06u: ", (long) tv.sec,
-			(unsigned int) tv.usec);
+		fprintf(out_file, "%s.%03u ", time_buffer, msecs);
 	} else
 #endif /* CONFIG_DEBUG_FILE */
-	printf("%ld.%06u: ", (long) tv.sec, (unsigned int) tv.usec);
+	printf("%s.%03u ", time_buffer, msecs);
 #endif /* CONFIG_ANDROID_LOG */
 }

diff -ruN wpa_supplicant/.config wpa_supplicant/.config
--- wpa_supplicant/.config	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant/.config	2016-07-19 10:25:48.566347508 +0200
@@ -0,0 +1,530 @@
+# Example wpa_supplicant build time configuration
+#
+# This file lists the configuration options that are used when building the
+# hostapd binary. All lines starting with # are ignored. Configuration option
+# lines must be commented out complete, if they are not to be included, i.e.,
+# just setting VARIABLE=n is not disabling that variable.
+#
+# This file is included in Makefile, so variables like CFLAGS and LIBS can also
+# be modified from here. In most cases, these lines should use += in order not
+# to override previous values of the variables.
+
+
+# Uncomment following two lines and fix the paths if you have installed OpenSSL
+# or GnuTLS in non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+# Example configuration for various cross-compilation platforms
+
+#### sveasoft (e.g., for Linksys WRT54G) ######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
+#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
+###############################################################################
+
+#### openwrt (e.g., for Linksys WRT54G) #######################################
+#CC=mipsel-uclibc-gcc
+#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
+#CFLAGS += -Os
+#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
+#	-I../WRT54GS/release/src/include
+#LIBS = -lssl
+###############################################################################
+
+
+# Driver interface for Host AP driver
+CONFIG_DRIVER_HOSTAP=y
+
+# Driver interface for Agere driver
+#CONFIG_DRIVER_HERMES=y
+# Change include directories to match with the local setup
+#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
+#CFLAGS += -I../../include/wireless
+
+# Driver interface for madwifi driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_MADWIFI=y
+# Set include directory to the madwifi source tree
+#CFLAGS += -I../../madwifi
+
+# Driver interface for ndiswrapper
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_NDISWRAPPER=y
+
+# Driver interface for Atmel driver
+CONFIG_DRIVER_ATMEL=y
+
+# Driver interface for old Broadcom driver
+# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
+# Linux wireless extensions and does not need (or even work) with the old
+# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
+#CONFIG_DRIVER_BROADCOM=y
+# Example path for wlioctl.h; change to match your configuration
+#CFLAGS += -I/opt/WRT54GS/release/src/include
+
+# Driver interface for Intel ipw2100/2200 driver
+# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
+#CONFIG_DRIVER_IPW=y
+
+# Driver interface for Ralink driver
+#CONFIG_DRIVER_RALINK=y
+
+# Driver interface for generic Linux wireless extensions
+# Note: WEXT is deprecated in the current Linux kernel version and no new
+# functionality is added to it. nl80211-based interface is the new
+# replacement for WEXT and its use allows wpa_supplicant to properly control
+# the driver to improve existing functionality like roaming and to support new
+# functionality.
+#CONFIG_DRIVER_WEXT=y
+
+# Driver interface for Linux drivers using the nl80211 kernel interface
+#CONFIG_DRIVER_NL80211=y
+
+# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
+CONFIG_DRIVER_BSD=y
+#CFLAGS += -I/usr/local/include
+#LIBS += -L/usr/local/lib
+#LIBS_p += -L/usr/local/lib
+#LIBS_c += -L/usr/local/lib
+
+# Driver interface for Windows NDIS
+#CONFIG_DRIVER_NDIS=y
+#CFLAGS += -I/usr/include/w32api/ddk
+#LIBS += -L/usr/local/lib
+# For native build using mingw
+#CONFIG_NATIVE_WINDOWS=y
+# Additional directories for cross-compilation on Linux host for mingw target
+#CFLAGS += -I/opt/mingw/mingw32/include/ddk
+#LIBS += -L/opt/mingw/mingw32/lib
+#CC=mingw32-gcc
+# By default, driver_ndis uses WinPcap for low-level operations. This can be
+# replaced with the following option which replaces WinPcap calls with NDISUIO.
+# However, this requires that WZC is disabled (net stop wzcsvc) before starting
+# wpa_supplicant.
+# CONFIG_USE_NDISUIO=y
+
+# Driver interface for development testing
+#CONFIG_DRIVER_TEST=y
+
+# Driver interface for wired Ethernet drivers
+CONFIG_DRIVER_WIRED=y
+
+# Driver interface for the Broadcom RoboSwitch family
+#CONFIG_DRIVER_ROBOSWITCH=y
+
+# Driver interface for no driver (e.g., WPS ER only)
+#CONFIG_DRIVER_NONE=y
+
+# Solaris libraries
+#LIBS += -lsocket -ldlpi -lnsl
+#LIBS_c += -lsocket
+
+# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
+# included)
+CONFIG_IEEE8021X_EAPOL=y
+
+# EAP-MD5
+CONFIG_EAP_MD5=y
+
+# EAP-MSCHAPv2
+CONFIG_EAP_MSCHAPV2=y
+
+# EAP-TLS
+CONFIG_EAP_TLS=y
+
+# EAL-PEAP
+CONFIG_EAP_PEAP=y
+
+# EAP-TTLS
+CONFIG_EAP_TTLS=y
+
+# EAP-FAST
+# Note: Default OpenSSL package does not include support for all the
+# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
+# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
+# to add the needed functions.
+#CONFIG_EAP_FAST=y
+
+# EAP-GTC
+CONFIG_EAP_GTC=y
+
+# EAP-OTP
+CONFIG_EAP_OTP=y
+
+# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
+CONFIG_EAP_SIM=y
+
+# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
+#CONFIG_EAP_PSK=y
+
+# EAP-pwd (secure authentication using only a password)
+#CONFIG_EAP_PWD=y
+
+# EAP-PAX
+#CONFIG_EAP_PAX=y
+
+# LEAP
+CONFIG_EAP_LEAP=y
+
+# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
+CONFIG_EAP_AKA=y
+
+# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
+# This requires CONFIG_EAP_AKA to be enabled, too.
+CONFIG_EAP_AKA_PRIME=y
+
+# Enable USIM simulator (Milenage) for EAP-AKA
+#CONFIG_USIM_SIMULATOR=y
+
+# EAP-SAKE
+#CONFIG_EAP_SAKE=y
+
+# EAP-GPSK
+#CONFIG_EAP_GPSK=y
+# Include support for optional SHA256 cipher suite in EAP-GPSK
+#CONFIG_EAP_GPSK_SHA256=y
+
+# EAP-TNC and related Trusted Network Connect support (experimental)
+#CONFIG_EAP_TNC=y
+
+# Wi-Fi Protected Setup (WPS)
+#CONFIG_WPS=y
+# Enable WSC 2.0 support
+#CONFIG_WPS2=y
+# Enable WPS external registrar functionality
+#CONFIG_WPS_ER=y
+# Disable credentials for an open network by default when acting as a WPS
+# registrar.
+#CONFIG_WPS_REG_DISABLE_OPEN=y
+# Enable WPS support with NFC config method
+#CONFIG_WPS_NFC=y
+
+# EAP-IKEv2
+CONFIG_EAP_IKEV2=y
+
+# PKCS#12 (PFX) support (used to read private key and certificate file from
+# a file that usually has extension .p12 or .pfx)
+CONFIG_PKCS12=y
+
+# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
+# engine.
+CONFIG_SMARTCARD=y
+
+# PC/SC interface for smartcards (USIM, GSM SIM).
+# CONFIG_PCSC means that smartcard communication will be handled by pcsc-lite library (needs to be installed seperately)
+# CONFIG_PCSC_RELAY means that smartcard communication will be relayed to the socket
+# Enable CONFIG_PCSC and optionally CONFIG_PCSC_RELAY if EAP-SIM or EAP-AKA is included
+CONFIG_PCSC=y
+CONFIG_PCSC_RELAY=y
+
+# Support HT overrides (disable HT/HT40, mask MCS rates, etc.)
+#CONFIG_HT_OVERRIDES=y
+
+# Development testing
+CONFIG_EAPOL_TEST=y
+
+# Select control interface backend for external programs, e.g, wpa_cli:
+# unix = UNIX domain sockets (default for Linux/*BSD)
+# udp = UDP sockets using localhost (127.0.0.1)
+# named_pipe = Windows Named Pipe (default for Windows)
+# udp-remote = UDP sockets with remote access (only for tests systems/purpose)
+# y = use default (backwards compatibility)
+# If this option is commented out, control interface is not included in the
+# build.
+CONFIG_CTRL_IFACE=y
+
+# Include support for GNU Readline and History Libraries in wpa_cli.
+# When building a wpa_cli binary for distribution, please note that these
+# libraries are licensed under GPL and as such, BSD license may not apply for
+# the resulting binary.
+#CONFIG_READLINE=y
+
+# Include internal line edit mode in wpa_cli. This can be used as a replacement
+# for GNU Readline to provide limited command line editing and history support.
+#CONFIG_WPA_CLI_EDIT=y
+
+# Remove debugging code that is printing out debug message to stdout.
+# This can be used to reduce the size of the wpa_supplicant considerably
+# if debugging code is not needed. The size reduction can be around 35%
+# (e.g., 90 kB).
+#CONFIG_NO_STDOUT_DEBUG=y
+
+# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
+# 35-50 kB in code size.
+#CONFIG_NO_WPA=y
+
+# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
+# save about 1 kB in code size when building only WPA-Personal (no EAP support)
+# or 6 kB if building for WPA-Enterprise.
+#CONFIG_NO_WPA2=y
+
+# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
+# This option can be used to reduce code size by removing support for
+# converting ASCII passphrases into PSK. If this functionality is removed, the
+# PSK can only be configured as the 64-octet hexstring (e.g., from
+# wpa_passphrase). This saves about 0.5 kB in code size.
+#CONFIG_NO_WPA_PASSPHRASE=y
+
+# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
+# This can be used if ap_scan=1 mode is never enabled.
+#CONFIG_NO_SCAN_PROCESSING=y
+
+# Select configuration backend:
+# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
+#	path is given on command line, not here; this option is just used to
+#	select the backend that allows configuration files to be used)
+# winreg = Windows registry (see win_example.reg for an example)
+CONFIG_BACKEND=file
+
+# Remove configuration write functionality (i.e., to allow the configuration
+# file to be updated based on runtime configuration changes). The runtime
+# configuration can still be changed, the changes are just not going to be
+# persistent over restarts. This option can be used to reduce code size by
+# about 3.5 kB.
+#CONFIG_NO_CONFIG_WRITE=y
+
+# Remove support for configuration blobs to reduce code size by about 1.5 kB.
+#CONFIG_NO_CONFIG_BLOBS=y
+
+# Select program entry point implementation:
+# main = UNIX/POSIX like main() function (default)
+# main_winsvc = Windows service (read parameters from registry)
+# main_none = Very basic example (development use only)
+#CONFIG_MAIN=main
+
+# Select wrapper for operatins system and C library specific functions
+# unix = UNIX/POSIX like systems (default)
+# win32 = Windows systems
+# none = Empty template
+#CONFIG_OS=unix
+
+# Select event loop implementation
+# eloop = select() loop (default)
+# eloop_win = Windows events and WaitForMultipleObject() loop
+# eloop_none = Empty template
+#CONFIG_ELOOP=eloop
+
+# Should we use poll instead of select? Select is used by default.
+#CONFIG_ELOOP_POLL=y
+
+# Select layer 2 packet implementation
+# linux = Linux packet socket (default)
+# pcap = libpcap/libdnet/WinPcap
+# freebsd = FreeBSD libpcap
+# winpcap = WinPcap with receive thread
+# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
+# none = Empty template
+CONFIG_L2_PACKET=linux
+
+# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
+CONFIG_PEERKEY=y
+
+# IEEE 802.11w (management frame protection), also known as PMF
+# Driver support is also needed for IEEE 802.11w.
+#CONFIG_IEEE80211W=y
+
+# Select TLS implementation
+# openssl = OpenSSL (default)
+# gnutls = GnuTLS
+# internal = Internal TLSv1 implementation (experimental)
+# none = Empty template
+#CONFIG_TLS=openssl
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.1)
+# can be enabled to get a stronger construction of messages when block ciphers
+# are used. It should be noted that some existing TLS v1.0 -based
+# implementation may not be compatible with TLS v1.1 message (ClientHello is
+# sent prior to negotiating which version will be used)
+#CONFIG_TLSV11=y
+
+# TLS-based EAP methods require at least TLS v1.0. Newer version of TLS (v1.2)
+# can be enabled to enable use of stronger crypto algorithms. It should be
+# noted that some existing TLS v1.0 -based implementation may not be compatible
+# with TLS v1.2 message (ClientHello is sent prior to negotiating which version
+# will be used)
+#CONFIG_TLSV12=y
+
+# If CONFIG_TLS=internal is used, additional library and include paths are
+# needed for LibTomMath. Alternatively, an integrated, minimal version of
+# LibTomMath can be used. See beginning of libtommath.c for details on benefits
+# and drawbacks of this option.
+#CONFIG_INTERNAL_LIBTOMMATH=y
+#ifndef CONFIG_INTERNAL_LIBTOMMATH
+#LTM_PATH=/usr/src/libtommath-0.39
+#CFLAGS += -I$(LTM_PATH)
+#LIBS += -L$(LTM_PATH)
+#LIBS_p += -L$(LTM_PATH)
+#endif
+# At the cost of about 4 kB of additional binary size, the internal LibTomMath
+# can be configured to include faster routines for exptmod, sqr, and div to
+# speed up DH and RSA calculation considerably
+#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
+
+# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
+# This is only for Windows builds and requires WMI-related header files and
+# WbemUuid.Lib from Platform SDK even when building with MinGW.
+#CONFIG_NDIS_EVENTS_INTEGRATED=y
+#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
+
+# Add support for old DBus control interface
+# (fi.epitest.hostap.WPASupplicant)
+#CONFIG_CTRL_IFACE_DBUS=y
+
+# Add support for new DBus control interface
+# (fi.w1.hostap.wpa_supplicant1)
+#CONFIG_CTRL_IFACE_DBUS_NEW=y
+
+# Add introspection support for new DBus control interface
+#CONFIG_CTRL_IFACE_DBUS_INTRO=y
+
+# Add support for loading EAP methods dynamically as shared libraries.
+# When this option is enabled, each EAP method can be either included
+# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
+# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
+# be loaded in the beginning of the wpa_supplicant configuration file
+# (see load_dynamic_eap parameter in the example file) before being used in
+# the network blocks.
+#
+# Note that some shared parts of EAP methods are included in the main program
+# and in order to be able to use dynamic EAP methods using these parts, the
+# main program must have been build with the EAP method enabled (=y or =dyn).
+# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
+# unless at least one of them was included in the main build to force inclusion
+# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
+# in the main build to be able to load these methods dynamically.
+#
+# Please also note that using dynamic libraries will increase the total binary
+# size. Thus, it may not be the best option for targets that have limited
+# amount of memory/flash.
+#CONFIG_DYNAMIC_EAP_METHODS=y
+
+# IEEE Std 802.11r-2008 (Fast BSS Transition)
+#CONFIG_IEEE80211R=y
+
+# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
+#CONFIG_DEBUG_FILE=y
+
+# Send debug messages to syslog instead of stdout
+#CONFIG_DEBUG_SYSLOG=y
+# Set syslog facility for debug messages
+#CONFIG_DEBUG_SYSLOG_FACILITY=LOG_DAEMON
+
+# Add support for sending all debug messages (regardless of debug verbosity)
+# to the Linux kernel tracing facility. This helps debug the entire stack by
+# making it easy to record everything happening from the driver up into the
+# same file, e.g., using trace-cmd.
+#CONFIG_DEBUG_LINUX_TRACING=y
+
+# Enable privilege separation (see README 'Privilege separation' for details)
+#CONFIG_PRIVSEP=y
+
+# Enable mitigation against certain attacks against TKIP by delaying Michael
+# MIC error reports by a random amount of time between 0 and 60 seconds
+#CONFIG_DELAYED_MIC_ERROR_REPORT=y
+
+# Enable tracing code for developer debugging
+# This tracks use of memory allocations and other registrations and reports
+# incorrect use with a backtrace of call (or allocation) location.
+#CONFIG_WPA_TRACE=y
+# For BSD, uncomment these.
+#LIBS += -lexecinfo
+#LIBS_p += -lexecinfo
+#LIBS_c += -lexecinfo
+
+# Use libbfd to get more details for developer debugging
+# This enables use of libbfd to get more detailed symbols for the backtraces
+# generated by CONFIG_WPA_TRACE=y.
+#CONFIG_WPA_TRACE_BFD=y
+# For BSD, uncomment these.
+#LIBS += -lbfd -liberty -lz
+#LIBS_p += -lbfd -liberty -lz
+#LIBS_c += -lbfd -liberty -lz
+
+# wpa_supplicant depends on strong random number generation being available
+# from the operating system. os_get_random() function is used to fetch random
+# data when needed, e.g., for key generation. On Linux and BSD systems, this
+# works by reading /dev/urandom. It should be noted that the OS entropy pool
+# needs to be properly initialized before wpa_supplicant is started. This is
+# important especially on embedded devices that do not have a hardware random
+# number generator and may by default start up with minimal entropy available
+# for random number generation.
+#
+# As a safety net, wpa_supplicant is by default trying to internally collect
+# additional entropy for generating random data to mix in with the data fetched
+# from the OS. This by itself is not considered to be very strong, but it may
+# help in cases where the system pool is not initialized properly. However, it
+# is very strongly recommended that the system pool is initialized with enough
+# entropy either by using hardware assisted random number generator or by
+# storing state over device reboots.
+#
+# wpa_supplicant can be configured to maintain its own entropy store over
+# restarts to enhance random number generation. This is not perfect, but it is
+# much more secure than using the same sequence of random numbers after every
+# reboot. This can be enabled with -e<entropy file> command line option. The
+# specified file needs to be readable and writable by wpa_supplicant.
+#
+# If the os_get_random() is known to provide strong random data (e.g., on
+# Linux/BSD, the board in question is known to have reliable source of random
+# data from /dev/urandom), the internal wpa_supplicant random pool can be
+# disabled. This will save some in binary size and CPU use. However, this
+# should only be considered for builds that are known to be used on devices
+# that meet the requirements described above.
+#CONFIG_NO_RANDOM_POOL=y
+
+# IEEE 802.11n (High Throughput) support (mainly for AP mode)
+#CONFIG_IEEE80211N=y
+
+# Wireless Network Management (IEEE Std 802.11v-2011)
+# Note: This is experimental and not complete implementation.
+#CONFIG_WNM=y
+
+# Interworking (IEEE 802.11u)
+# This can be used to enable functionality to improve interworking with
+# external networks (GAS/ANQP to learn more about the networks and network
+# selection based on available credentials).
+#CONFIG_INTERWORKING=y
+
+# Hotspot 2.0
+#CONFIG_HS20=y
+
+# AP mode operations with wpa_supplicant
+# This can be used for controlling AP mode operations with wpa_supplicant. It
+# should be noted that this is mainly aimed at simple cases like
+# WPA2-Personal while more complex configurations like WPA2-Enterprise with an
+# external RADIUS server can be supported with hostapd.
+#CONFIG_AP=y
+
+# P2P (Wi-Fi Direct)
+# This can be used to enable P2P support in wpa_supplicant. See README-P2P for
+# more information on P2P operations.
+#CONFIG_P2P=y
+
+# Autoscan
+# This can be used to enable automatic scan support in wpa_supplicant.
+#Â See wpa_supplicant.conf for more information on autoscan usage.
+#
+# Enabling directly a module will enable autoscan support.
+# For exponential module:
+#CONFIG_AUTOSCAN_EXPONENTIAL=y
+# For periodic module:
+#CONFIG_AUTOSCAN_PERIODIC=y
+
+# Password (and passphrase, etc.) backend for external storage
+# These optional mechanisms can be used to add support for storing passwords
+# and other secrets in external (to wpa_supplicant) location. This allows, for
+# example, operating system specific key storage to be used
+#
+# External password backend for testing purposes (developer use)
+#CONFIG_EXT_PASSWORD_TEST=y
+
+
+# Enable this option if you want IPv6 support in addition to IPv4
+CONFIG_IPV6=y
diff -ruN wpa_supplicant/config.c wpa_supplicant/config.c
--- wpa_supplicant/config.c	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/config.c	2016-07-19 08:27:52.306681133 +0200
@@ -1606,6 +1606,8 @@
 	{ INTe(engine) },
 	{ INTe(engine2) },
 	{ INT(eapol_flags) },
+	{ STRe(imsi) },
+	{ INTe(mnc_len) },
 #endif /* IEEE8021X_EAPOL */
 	{ FUNC_KEY(wep_key0) },
 	{ FUNC_KEY(wep_key1) },
@@ -1790,6 +1792,7 @@
 	os_free(eap->pending_req_otp);
 	os_free(eap->pac_file);
 	os_free(eap->new_password);
+	os_free(eap->imsi);
 }
 #endif /* IEEE8021X_EAPOL */

@@ -2035,6 +2038,7 @@
 	ssid->eapol_flags = DEFAULT_EAPOL_FLAGS;
 	ssid->eap_workaround = DEFAULT_EAP_WORKAROUND;
 	ssid->eap.fragment_size = DEFAULT_FRAGMENT_SIZE;
+	ssid->eap.mnc_len = 0;
 #endif /* IEEE8021X_EAPOL */
 #ifdef CONFIG_HT_OVERRIDES
 	ssid->disable_ht = DEFAULT_DISABLE_HT;
diff -ruN wpa_supplicant/config_file.c wpa_supplicant/config_file.c
--- wpa_supplicant/config_file.c	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/config_file.c	2016-07-19 08:27:52.306681133 +0200
@@ -666,6 +666,8 @@
 	STR(ca_cert2_id);
 	INTe(engine);
 	INTe(engine2);
+	STR(imsi);
+	INTe(mnc_len);
 	INT_DEF(eapol_flags, DEFAULT_EAPOL_FLAGS);
 #endif /* IEEE8021X_EAPOL */
 	for (i = 0; i < 4; i++)
diff -ruN wpa_supplicant/eapol_test.c wpa_supplicant/eapol_test.c
--- wpa_supplicant/eapol_test.c	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/eapol_test.c	2016-07-19 08:27:52.306681133 +0200
@@ -893,7 +893,9 @@
 	unsigned char aka_ik[IK_LEN];
 	unsigned char aka_ck[CK_LEN];

+#ifndef PCSC_RELAY_FUNCS
 	scard = scard_init(SCARD_TRY_BOTH, NULL);
+#endif
 	if (scard == NULL)
 		return -1;
 	if (scard_set_pin(scard, "1234")) {
@@ -992,8 +994,9 @@
 		/* disable debug output */
 		wpa_debug_level = 99;
 	}
-
+#ifndef PCSC_RELAY_FUNCS
 	scard = scard_init(SCARD_GSM_SIM_ONLY, NULL);
+#endif
 	if (scard == NULL) {
 		printf("Failed to open smartcard connection\n");
 		return -1;
diff -ruN wpa_supplicant/events.c wpa_supplicant/events.c
--- wpa_supplicant/events.c	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/events.c	2016-07-19 08:27:52.306681133 +0200
@@ -311,10 +311,13 @@
 	else
 		type = SCARD_GSM_SIM_ONLY;

+#ifdef PCSC_RELAY_FUNCS
+    wpa_s->scard = scard_init(type, ssid->eap.imsi, ssid->eap.mnc_len, wpa_s->caller_sockfd, wpa_s->challenge_code);
+#else
 	wpa_s->scard = scard_init(type, NULL);
+#endif
 	if (wpa_s->scard == NULL) {
-		wpa_msg(wpa_s, MSG_WARNING, "Failed to initialize SIM "
-			"(pcsc-lite)");
+		wpa_msg(wpa_s, MSG_WARNING, "Failed to initialize SIM ");
 		return -1;
 	}
 	wpa_sm_set_scard_ctx(wpa_s->wpa, wpa_s->scard);
diff -ruN wpa_supplicant/Makefile wpa_supplicant/Makefile
--- wpa_supplicant/Makefile	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/Makefile	2016-07-19 10:24:44.902121517 +0200
@@ -3,7 +3,7 @@
 endif

 ifndef CFLAGS
-CFLAGS = -MMD -O2 -Wall -g
+CFLAGS = -MMD -Wall -g
 endif

 export LIBDIR ?= /usr/local/lib/
@@ -807,14 +807,13 @@

 ifdef CONFIG_PCSC
 # PC/SC interface for smartcards (USIM, GSM SIM)
-CFLAGS += -DPCSC_FUNCS -I/usr/include/PCSC
+CFLAGS += -DPCSC_FUNCS
 OBJS += ../src/utils/pcsc_funcs.o
-# -lpthread may not be needed depending on how pcsc-lite was configured
-ifdef CONFIG_NATIVE_WINDOWS
-#Once MinGW gets support for WinScard, -lwinscard could be used instead of the
-#dynamic symbol loading that is now used in pcsc_funcs.c
-#LIBS += -lwinscard
+ifdef CONFIG_PCSC_RELAY
+CFLAGS += -DPCSC_RELAY_FUNCS
 else
+CFLAGS += -I/usr/include/PCSC
+# -lpthread may not be needed depending on how pcsc-lite was configured
 LIBS += -lpcsclite -lpthread
 endif
 endif
@@ -1292,7 +1291,7 @@
 endif

 ifdef CONFIG_IPV6
-# for eapol_test only
+# for radeapclient only
 CFLAGS += -DCONFIG_IPV6
 endif

@@ -1415,7 +1414,7 @@
 endif
 OBJS_wpa += $(OBJS_l2)
 OBJS += wpa_supplicant.o events.o blacklist.o wpas_glue.o scan.o
-OBJS_t := $(OBJS) $(OBJS_l2) eapol_test.o
+OBJS_t := $(OBJS) $(OBJS_l2) radeapclient.o
 OBJS_t += ../src/radius/radius_client.o
 OBJS_t += ../src/radius/radius.o
 ifndef CONFIG_AP
@@ -1510,8 +1509,8 @@
 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
 	@$(E) "  LD " $@

-eapol_test: $(OBJS_t)
-	$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
+radeapclient: $(OBJS_t)
+	$(Q)$(LDO) $(LDFLAGS) -o radeapclient $(OBJS_t) $(LIBS)
 	@$(E) "  LD " $@

 preauth_test: $(OBJS_t2)
@@ -1623,7 +1622,7 @@
 clean:
 	$(MAKE) -C ../src clean
 	$(MAKE) -C dbus clean
-	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL) eapol_test preauth_test
+	rm -f core *~ *.o *.d eap_*.so $(ALL) $(WINALL) radeapclient preauth_test
 	rm -f wpa_priv
 	rm -f nfc_pw_token

diff -ruN wpa_supplicant/radeapclient-aka.conf wpa_supplicant/radeapclient-aka.conf
--- wpa_supplicant/radeapclient-aka.conf	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant/radeapclient-aka.conf	2016-07-19 08:27:52.310681222 +0200
@@ -0,0 +1,7 @@
+# EAP-SIM with a GSM SIM or USIM
+network={
+	ssid="eap-aka-test"
+	key_mgmt=WPA-EAP
+	eap=AKA
+	pcsc=""
+}
diff -ruN wpa_supplicant/radeapclient.c wpa_supplicant/radeapclient.c
--- wpa_supplicant/radeapclient.c	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant/radeapclient.c	2016-07-19 08:27:52.310681222 +0200
@@ -0,0 +1,1258 @@
+/*
+ * radeapclient
+ * Derived from radeapclient
+ * Copyright (c) 2012-2013, Andrei Korostelev
+ * Copyright (c) 2003-2012, Jouni Malinen <j@w1.fi>
+ */
+
+#include "includes.h"
+#include <assert.h>
+#include <ctype.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netdb.h>
+#include <errno.h>
+
+#include "common.h"
+#include "utils/ext_password.h"
+#include "config.h"
+#include "eapol_supp/eapol_supp_sm.h"
+#include "eap_peer/eap.h"
+#include "eap_server/eap_methods.h"
+#include "eloop.h"
+#include "utils/base64.h"
+#include "rsn_supp/wpa.h"
+#include "eap_peer/eap_i.h"
+#include "wpa_supplicant_i.h"
+#include "radius/radius.h"
+#include "radius/radius_client.h"
+#include "common/wpa_ctrl.h"
+#include "ctrl_iface.h"
+#include "pcsc_funcs.h"
+#include "radeapclient.h"
+
+extern int wpa_debug_level;
+extern int wpa_debug_timestamp;
+extern int wpa_debug_show_keys;
+
+struct wpa_driver_ops *wpa_drivers[] = { NULL };
+
+
+
+struct extra_radius_attr {
+	u8 type;
+	char syntax;
+	char *data;
+	struct extra_radius_attr *next;
+};
+
+struct radeapclient_data_t {
+	struct wpa_supplicant *wpa_s;
+
+	int radeapclient_num_reauths;
+	int no_mppe_keys;
+	int num_mppe_ok, num_mppe_mismatch;
+
+	u8 radius_identifier;
+	struct radius_msg *last_recv_radius;
+	struct in_addr own_ip_addr;
+	struct radius_client_data *radius;
+	struct hostapd_radius_servers *radius_conf;
+
+	 /* last received EAP Response from Authentication Server */
+	struct wpabuf *last_eap_radius;
+
+	u8 authenticator_pmk[PMK_LEN];
+	size_t authenticator_pmk_len;
+	int radius_access_accept_received;
+	int radius_access_reject_received;
+	int auth_timed_out;
+
+	u8 *eap_identity;
+	size_t eap_identity_len;
+
+	char *connect_info;
+	u8 own_addr[ETH_ALEN];
+	struct extra_radius_attr *extra_attrs;
+
+	FILE *server_cert_file;
+};
+
+static struct radeapclient_data_t radeapclient_data;
+
+
+static void send_eap_request_identity(void *eloop_ctx, void *timeout_ctx);
+
+
+
+// Initialize connection to the caller
+// caller_sockfd_ptr [out] if function succeeds contains connection socket
+static int init_caller_connection(int port, int* caller_sockfd_ptr)
+{
+    *caller_sockfd_ptr = -1;
+    int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (sock < 0)
+    {
+        wpa_printf(MSG_ERROR, "Error setting up TCP socket. %s", strerror(errno));
+        return -1;
+    }
+    int tcp_no_delay = 1;
+    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char*)&tcp_no_delay, sizeof(tcp_no_delay)) < 0)
+    {
+        wpa_printf(MSG_ERROR, "Cannot set TCP_NODELAY in socket. %s", strerror(errno));
+        return -1;
+    }
+    struct sockaddr_in self_addr = {0};
+    self_addr.sin_family = AF_INET;
+    int ret = inet_pton(AF_INET, rad_eap_client_connect_ipv4, &self_addr.sin_addr);
+    if (ret == 0)
+    {
+        wpa_printf(MSG_ERROR, "%s is invalid IP address", rad_eap_client_connect_ipv4);
+        return -1;
+    }
+    if (ret < 0)
+    {
+        wpa_printf(MSG_ERROR, "radclient: cannot initialize address. %s", strerror(errno));
+        return -1;
+    }
+    self_addr.sin_port = htons(port);
+    if (connect(sock, (struct sockaddr*)&self_addr, sizeof(self_addr)) < 0)
+    {
+        wpa_printf(MSG_ERROR, "Connect to %s:%d failed. %s", rad_eap_client_connect_ipv4, port, strerror(errno));
+        return -1;
+    }
+    *caller_sockfd_ptr = sock;
+    wpa_printf(MSG_INFO, "Connected to the caller at %s:%d", rad_eap_client_connect_ipv4, port);
+    return 0;
+}
+
+
+// notify caller on exit reason in case we are connected to it
+static int notify_caller(int sockfd, int32_t exit_code)
+{
+    if (sockfd == -1)
+        return 0; // this is ok
+
+    int32_t msg_code = rad_eap_client_msg_code_default_error;
+    switch (exit_code)
+    {
+    case rad_eap_client_exit_code_auth_ok:
+        msg_code = rad_eap_client_msg_code_auth_ok;
+        break;
+    case rad_eap_client_exit_code_auth_nok:
+        msg_code = rad_eap_client_msg_code_auth_nok;
+        break;
+    case rad_eap_client_exit_code_radius_svr_connection_error:
+        msg_code = rad_eap_client_msg_code_radius_svr_connection_error;
+        break;
+    case rad_eap_client_exit_code_default_error:
+    default:
+        msg_code = rad_eap_client_msg_code_default_error;
+        break;
+    }
+
+    return scard_send_code_with_data(sockfd, msg_code, NULL, 0);
+}
+
+// static void close_connection_with_caller(int sockfd)
+// {
+    // if (sockfd != -1)
+    // {
+        // shutdown(sockfd, SHUT_RDWR);
+        // close(sockfd);
+        // sockfd = -1;
+    // }
+// }
+
+
+static void hostapd_logger_cb(void *ctx, const u8 *addr, unsigned int module,
+			      int level, const char *txt, size_t len)
+{
+	if (addr)
+		wpa_printf(MSG_DEBUG, "STA " MACSTR ": %s",
+			   MAC2STR(addr), txt);
+	else
+		wpa_printf(MSG_DEBUG, "%s", txt);
+}
+
+
+static int add_extra_attr(struct radius_msg *msg,
+			  struct extra_radius_attr *attr)
+{
+	size_t len;
+	char *pos;
+	u32 val;
+	char buf[RADIUS_MAX_ATTR_LEN + 1];
+
+	switch (attr->syntax) {
+	case 's':
+		os_snprintf(buf, sizeof(buf), "%s", attr->data);
+		len = os_strlen(buf);
+		break;
+	case 'n':
+		buf[0] = '\0';
+		len = 1;
+		break;
+	case 'x':
+		pos = attr->data;
+		if (pos[0] == '0' && pos[1] == 'x')
+			pos += 2;
+		len = os_strlen(pos);
+		if ((len & 1) || (len / 2) > RADIUS_MAX_ATTR_LEN) {
+			wpa_printf(MSG_ERROR, "Invalid extra attribute hexstring");
+			return -1;
+		}
+		len /= 2;
+		if (hexstr2bin(pos, (u8 *) buf, len) < 0) {
+			wpa_printf(MSG_ERROR, "Invalid extra attribute hexstring");
+			return -1;
+		}
+		break;
+	case 'd':
+		val = htonl(atoi(attr->data));
+		os_memcpy(buf, &val, 4);
+		len = 4;
+		break;
+	default:
+		wpa_printf(MSG_ERROR, "Incorrect extra attribute syntax specification");
+		return -1;
+	}
+
+	if (!radius_msg_add_attr(msg, attr->type, (u8 *) buf, len)) {
+		wpa_printf(MSG_ERROR, "Could not add attribute %d", attr->type);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static int add_extra_attrs(struct radius_msg *msg,
+			   struct extra_radius_attr *attrs)
+{
+	struct extra_radius_attr *p;
+	for (p = attrs; p; p = p->next) {
+		if (add_extra_attr(msg, p) < 0)
+			return -1;
+	}
+	return 0;
+}
+
+
+static struct extra_radius_attr *
+find_extra_attr(struct extra_radius_attr *attrs, u8 type)
+{
+	struct extra_radius_attr *p;
+	for (p = attrs; p; p = p->next) {
+		if (p->type == type)
+			return p;
+	}
+	return NULL;
+}
+
+
+static void ieee802_1x_encapsulate_radius(struct radeapclient_data_t *e,
+					  const u8 *eap, size_t len)
+{
+	struct radius_msg *msg;
+	char buf[RADIUS_MAX_ATTR_LEN + 1];
+	const struct eap_hdr *hdr;
+	const u8 *pos;
+
+	wpa_printf(MSG_DEBUG, "Encapsulating EAP message into a RADIUS "
+		   "packet");
+
+	e->radius_identifier = radius_client_get_id(e->radius);
+	msg = radius_msg_new(RADIUS_CODE_ACCESS_REQUEST,
+			     e->radius_identifier);
+	if (msg == NULL) {
+		wpa_printf(MSG_ERROR, "Could not create net RADIUS packet");
+		return;
+	}
+
+	radius_msg_make_authenticator(msg, (u8 *) e, sizeof(*e));
+
+	hdr = (const struct eap_hdr *) eap;
+	pos = (const u8 *) (hdr + 1);
+	if (len > sizeof(*hdr) && hdr->code == EAP_CODE_RESPONSE &&
+	    pos[0] == EAP_TYPE_IDENTITY) {
+		pos++;
+		os_free(e->eap_identity);
+		e->eap_identity_len = len - sizeof(*hdr) - 1;
+		e->eap_identity = os_malloc(e->eap_identity_len);
+		if (e->eap_identity) {
+			os_memcpy(e->eap_identity, pos, e->eap_identity_len);
+			wpa_hexdump(MSG_DEBUG, "Learned identity from "
+				    "EAP-Response-Identity",
+				    e->eap_identity, e->eap_identity_len);
+		}
+	}
+
+	if (e->eap_identity &&
+	    !radius_msg_add_attr(msg, RADIUS_ATTR_USER_NAME,
+				 e->eap_identity, e->eap_identity_len)) {
+		wpa_printf(MSG_ERROR, "Could not add User-Name");
+		goto fail;
+	}
+
+	if (!find_extra_attr(e->extra_attrs, RADIUS_ATTR_NAS_IP_ADDRESS) &&
+	    !radius_msg_add_attr(msg, RADIUS_ATTR_NAS_IP_ADDRESS,
+				 (u8 *) &e->own_ip_addr, 4)) {
+		wpa_printf(MSG_ERROR, "Could not add NAS-IP-Address");
+		goto fail;
+	}
+
+	os_snprintf(buf, sizeof(buf), RADIUS_802_1X_ADDR_FORMAT,
+		    MAC2STR(e->wpa_s->own_addr));
+	if (!find_extra_attr(e->extra_attrs, RADIUS_ATTR_CALLING_STATION_ID)
+	    &&
+	    !radius_msg_add_attr(msg, RADIUS_ATTR_CALLING_STATION_ID,
+				 (u8 *) buf, os_strlen(buf))) {
+		wpa_printf(MSG_ERROR, "Could not add Calling-Station-Id");
+		goto fail;
+	}
+
+	/* TODO: should probably check MTU from driver config; 2304 is max for
+	 * IEEE 802.11, but use 1400 to avoid problems with too large packets
+	 */
+	if (!find_extra_attr(e->extra_attrs, RADIUS_ATTR_FRAMED_MTU) &&
+	    !radius_msg_add_attr_int32(msg, RADIUS_ATTR_FRAMED_MTU, 1400)) {
+		wpa_printf(MSG_ERROR, "Could not add Framed-MTU");
+		goto fail;
+	}
+
+	if (!find_extra_attr(e->extra_attrs, RADIUS_ATTR_NAS_PORT_TYPE) &&
+	    !radius_msg_add_attr_int32(msg, RADIUS_ATTR_NAS_PORT_TYPE,
+				       RADIUS_NAS_PORT_TYPE_IEEE_802_11)) {
+		wpa_printf(MSG_ERROR, "Could not add NAS-Port-Type");
+		goto fail;
+	}
+
+	os_snprintf(buf, sizeof(buf), "%s", e->connect_info);
+	if (!find_extra_attr(e->extra_attrs, RADIUS_ATTR_CONNECT_INFO) &&
+	    !radius_msg_add_attr(msg, RADIUS_ATTR_CONNECT_INFO,
+				 (u8 *) buf, os_strlen(buf))) {
+		wpa_printf(MSG_ERROR, "Could not add Connect-Info");
+		goto fail;
+	}
+
+	if (add_extra_attrs(msg, e->extra_attrs) < 0)
+		goto fail;
+
+	if (eap && !radius_msg_add_eap(msg, eap, len)) {
+		wpa_printf(MSG_ERROR, "Could not add EAP-Message");
+		goto fail;
+	}
+
+	/* State attribute must be copied if and only if this packet is
+	 * Access-Request reply to the previous Access-Challenge */
+	if (e->last_recv_radius &&
+	    radius_msg_get_hdr(e->last_recv_radius)->code ==
+	    RADIUS_CODE_ACCESS_CHALLENGE) {
+		int res = radius_msg_copy_attr(msg, e->last_recv_radius,
+					       RADIUS_ATTR_STATE);
+		if (res < 0) {
+			wpa_printf(MSG_ERROR, "Could not copy State attribute from previous "
+			       "Access-Challenge");
+			goto fail;
+		}
+		if (res > 0) {
+			wpa_printf(MSG_DEBUG, "  Copied RADIUS State "
+				   "Attribute");
+		}
+	}
+
+	if (radius_client_send(e->radius, msg, RADIUS_AUTH, e->wpa_s->own_addr)
+	    < 0)
+		goto fail;
+	return;
+
+ fail:
+	radius_msg_free(msg);
+}
+
+
+static int radeapclient_eapol_send(void *ctx, int type, const u8 *buf,
+				 size_t len)
+{
+	wpa_printf(MSG_DEBUG, "WPA: radeapclient_eapol_send(type=%d len=%lu)",
+	       type, (unsigned long) len);
+	if (type == IEEE802_1X_TYPE_EAP_PACKET) {
+		wpa_hexdump(MSG_DEBUG, "TX EAP -> RADIUS", buf, len);
+		ieee802_1x_encapsulate_radius(&radeapclient_data, buf, len);
+	}
+	return 0;
+}
+
+
+static void radeapclient_set_config_blob(void *ctx,
+				       struct wpa_config_blob *blob)
+{
+	struct radeapclient_data_t *e = ctx;
+	wpa_config_set_blob(e->wpa_s->conf, blob);
+}
+
+
+static const struct wpa_config_blob *
+radeapclient_get_config_blob(void *ctx, const char *name)
+{
+	struct radeapclient_data_t *e = ctx;
+	return wpa_config_get_blob(e->wpa_s->conf, name);
+}
+
+
+static void radeapclient_eapol_done_cb(void *ctx)
+{
+	wpa_printf(MSG_INFO, "WPA: EAPOL processing complete");
+}
+
+
+static void eapol_sm_reauth(void *eloop_ctx, void *timeout_ctx)
+{
+	struct radeapclient_data_t *e = eloop_ctx;
+	wpa_printf(MSG_INFO, "\n\n\n\%s: Triggering EAP reauthentication\n", rad_eap_client_prog_name);
+	e->radius_access_accept_received = 0;
+	send_eap_request_identity(e->wpa_s, NULL);
+}
+
+
+static int radeapclient_compare_pmk(struct radeapclient_data_t *e)
+{
+	u8 pmk[PMK_LEN];
+	int ret = 1;
+
+	if (eapol_sm_get_key(e->wpa_s->eapol, pmk, PMK_LEN) == 0) {
+		wpa_hexdump(MSG_DEBUG, "PMK from EAPOL", pmk, PMK_LEN);
+		if (os_memcmp(pmk, e->authenticator_pmk, PMK_LEN) != 0) {
+			wpa_printf(MSG_WARNING, "WARNING: PMK mismatch");
+			wpa_hexdump(MSG_DEBUG, "PMK from AS",
+				    e->authenticator_pmk, PMK_LEN);
+		} else if (e->radius_access_accept_received)
+			ret = 0;
+	} else if (e->authenticator_pmk_len == 16 &&
+		   eapol_sm_get_key(e->wpa_s->eapol, pmk, 16) == 0) {
+		wpa_hexdump(MSG_DEBUG, "LEAP PMK from EAPOL", pmk, 16);
+		if (os_memcmp(pmk, e->authenticator_pmk, 16) != 0) {
+			wpa_printf(MSG_WARNING, "WARNING: PMK mismatch");
+			wpa_hexdump(MSG_DEBUG, "PMK from AS",
+				    e->authenticator_pmk, 16);
+		} else if (e->radius_access_accept_received)
+			ret = 0;
+	} else if (e->radius_access_accept_received && e->no_mppe_keys) {
+		/* No keying material expected */
+		ret = 0;
+	}
+
+	if (ret && !e->no_mppe_keys)
+		e->num_mppe_mismatch++;
+	else if (!e->no_mppe_keys)
+		e->num_mppe_ok++;
+
+	return ret;
+}
+
+
+static void eapol_sm_cb(struct eapol_sm *eapol, int success, void *ctx)
+{
+	struct radeapclient_data_t *e = ctx;
+	wpa_printf(MSG_DEBUG, "eapol_sm_cb: success=%d", success);
+	e->radeapclient_num_reauths--;
+	if (e->radeapclient_num_reauths < 0)
+		eloop_terminate();
+	else {
+		radeapclient_compare_pmk(e);
+		eloop_register_timeout(0, 100000, eapol_sm_reauth, e, NULL);
+	}
+}
+
+
+static void radeapclient_write_cert(FILE *f, const char *subject,
+				  const struct wpabuf *cert)
+{
+	unsigned char *encoded;
+
+	encoded = base64_encode(wpabuf_head(cert), wpabuf_len(cert), NULL);
+	if (encoded == NULL)
+		return;
+	fprintf(f, "%s\n-----BEGIN CERTIFICATE-----\n%s"
+		"-----END CERTIFICATE-----\n\n", subject, encoded);
+	os_free(encoded);
+}
+
+
+static void radeapclient_cert_cb(void *ctx, int depth, const char *subject,
+			       const char *cert_hash,
+			       const struct wpabuf *cert)
+{
+	struct radeapclient_data_t *e = ctx;
+
+	wpa_msg(e->wpa_s, MSG_INFO, WPA_EVENT_EAP_PEER_CERT
+		"depth=%d subject='%s'%s%s",
+		depth, subject,
+		cert_hash ? " hash=" : "",
+		cert_hash ? cert_hash : "");
+
+	if (cert) {
+		char *cert_hex;
+		size_t len = wpabuf_len(cert) * 2 + 1;
+		cert_hex = os_malloc(len);
+		if (cert_hex) {
+			wpa_snprintf_hex(cert_hex, len, wpabuf_head(cert),
+					 wpabuf_len(cert));
+			wpa_msg_ctrl(e->wpa_s, MSG_INFO,
+				     WPA_EVENT_EAP_PEER_CERT
+				     "depth=%d subject='%s' cert=%s",
+				     depth, subject, cert_hex);
+			os_free(cert_hex);
+		}
+
+		if (e->server_cert_file)
+			radeapclient_write_cert(e->server_cert_file,
+					      subject, cert);
+	}
+}
+
+
+static void radeapclient_set_anon_id(void *ctx, const u8 *id, size_t len)
+{
+	struct radeapclient_data_t *e = ctx;
+	struct wpa_supplicant *wpa_s = e->wpa_s;
+	char *str;
+	int res;
+
+	wpa_hexdump_ascii(MSG_DEBUG, "EAP method updated anonymous_identity",
+			  id, len);
+
+	if (wpa_s->current_ssid == NULL)
+		return;
+
+	if (id == NULL) {
+		if (wpa_config_set(wpa_s->current_ssid, "anonymous_identity",
+				   "NULL", 0) < 0)
+			return;
+	} else {
+		str = os_malloc(len * 2 + 1);
+		if (str == NULL)
+			return;
+		wpa_snprintf_hex(str, len * 2 + 1, id, len);
+		res = wpa_config_set(wpa_s->current_ssid, "anonymous_identity",
+				     str, 0);
+		os_free(str);
+		if (res < 0)
+			return;
+	}
+}
+
+
+static int test_eapol(struct radeapclient_data_t *e, struct wpa_supplicant *wpa_s,
+		      struct wpa_ssid *ssid)
+{
+	struct eapol_config eapol_conf;
+	struct eapol_ctx *ctx;
+
+	ctx = os_zalloc(sizeof(*ctx));
+	if (ctx == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to allocate EAPOL context.");
+		return -1;
+	}
+	ctx->ctx = e;
+	ctx->msg_ctx = wpa_s;
+	ctx->scard_ctx = wpa_s->scard;
+	ctx->cb = eapol_sm_cb;
+	ctx->cb_ctx = e;
+	ctx->eapol_send_ctx = wpa_s;
+	ctx->preauth = 0;
+	ctx->eapol_done_cb = radeapclient_eapol_done_cb;
+	ctx->eapol_send = radeapclient_eapol_send;
+	ctx->set_config_blob = radeapclient_set_config_blob;
+	ctx->get_config_blob = radeapclient_get_config_blob;
+	ctx->opensc_engine_path = wpa_s->conf->opensc_engine_path;
+	ctx->pkcs11_engine_path = wpa_s->conf->pkcs11_engine_path;
+	ctx->pkcs11_module_path = wpa_s->conf->pkcs11_module_path;
+	ctx->cert_cb = radeapclient_cert_cb;
+	ctx->cert_in_cb = 1;
+	ctx->set_anon_id = radeapclient_set_anon_id;
+
+	wpa_s->eapol = eapol_sm_init(ctx);
+	if (wpa_s->eapol == NULL) {
+		os_free(ctx);
+		wpa_printf(MSG_ERROR, "Failed to initialize EAPOL state machines.");
+		return -1;
+	}
+
+	wpa_s->current_ssid = ssid;
+	os_memset(&eapol_conf, 0, sizeof(eapol_conf));
+	eapol_conf.accept_802_1x_keys = 1;
+	eapol_conf.required_keys = 0;
+	eapol_conf.fast_reauth = wpa_s->conf->fast_reauth;
+	eapol_conf.workaround = ssid->eap_workaround;
+	eapol_sm_notify_config(wpa_s->eapol, &ssid->eap, &eapol_conf);
+	eapol_sm_register_scard_ctx(wpa_s->eapol, wpa_s->scard);
+
+
+	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
+	/* 802.1X::portControl = Auto */
+	eapol_sm_notify_portEnabled(wpa_s->eapol, TRUE);
+
+	return 0;
+}
+
+
+static void test_eapol_clean(struct radeapclient_data_t *e,
+			     struct wpa_supplicant *wpa_s)
+{
+	struct extra_radius_attr *p, *prev;
+
+	radius_client_deinit(e->radius);
+	wpabuf_free(e->last_eap_radius);
+	radius_msg_free(e->last_recv_radius);
+	e->last_recv_radius = NULL;
+	os_free(e->eap_identity);
+	e->eap_identity = NULL;
+	eapol_sm_deinit(wpa_s->eapol);
+	wpa_s->eapol = NULL;
+	if (e->radius_conf && e->radius_conf->auth_server) {
+		os_free(e->radius_conf->auth_server->shared_secret);
+		os_free(e->radius_conf->auth_server);
+	}
+	os_free(e->radius_conf);
+	e->radius_conf = NULL;
+	scard_deinit(wpa_s->scard);
+	if (wpa_s->ctrl_iface) {
+		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
+		wpa_s->ctrl_iface = NULL;
+	}
+
+	ext_password_deinit(wpa_s->ext_pw);
+	wpa_s->ext_pw = NULL;
+
+	wpa_config_free(wpa_s->conf);
+
+	p = e->extra_attrs;
+	while (p) {
+		prev = p;
+		p = p->next;
+		os_free(prev);
+	}
+}
+
+
+static void send_eap_request_identity(void *eloop_ctx, void *timeout_ctx)
+{
+	struct wpa_supplicant *wpa_s = eloop_ctx;
+	u8 buf[100], *pos;
+	struct ieee802_1x_hdr *hdr;
+	struct eap_hdr *eap;
+
+	hdr = (struct ieee802_1x_hdr *) buf;
+	hdr->version = EAPOL_VERSION;
+	hdr->type = IEEE802_1X_TYPE_EAP_PACKET;
+	hdr->length = htons(5);
+
+	eap = (struct eap_hdr *) (hdr + 1);
+	eap->code = EAP_CODE_REQUEST;
+	eap->identifier = 0;
+	eap->length = htons(5);
+	pos = (u8 *) (eap + 1);
+	*pos = EAP_TYPE_IDENTITY;
+
+	wpa_printf(MSG_INFO, "Sending fake EAP-Request-Identity");
+	eapol_sm_rx_eapol(wpa_s->eapol, wpa_s->bssid, buf,
+			  sizeof(*hdr) + 5);
+}
+
+
+static void radeapclient_timeout(void *eloop_ctx, void *timeout_ctx)
+{
+	struct radeapclient_data_t *e = eloop_ctx;
+	wpa_printf(MSG_ERROR, "EAPOL test timed out");
+	e->auth_timed_out = 1;
+	eloop_terminate();
+}
+
+
+static char *eap_type_text(u8 type)
+{
+	switch (type) {
+	case EAP_TYPE_IDENTITY: return "Identity";
+	case EAP_TYPE_NOTIFICATION: return "Notification";
+	case EAP_TYPE_NAK: return "Nak";
+	case EAP_TYPE_TLS: return "TLS";
+	case EAP_TYPE_TTLS: return "TTLS";
+	case EAP_TYPE_PEAP: return "PEAP";
+	case EAP_TYPE_SIM: return "SIM";
+	case EAP_TYPE_GTC: return "GTC";
+	case EAP_TYPE_MD5: return "MD5";
+	case EAP_TYPE_OTP: return "OTP";
+	case EAP_TYPE_FAST: return "FAST";
+	case EAP_TYPE_SAKE: return "SAKE";
+	case EAP_TYPE_PSK: return "PSK";
+	default: return "Unknown";
+	}
+}
+
+
+static void ieee802_1x_decapsulate_radius(struct radeapclient_data_t *e)
+{
+	struct wpabuf *eap;
+	const struct eap_hdr *hdr;
+	int eap_type = -1;
+	char buf[64];
+	struct radius_msg *msg;
+
+	if (e->last_recv_radius == NULL)
+		return;
+
+	msg = e->last_recv_radius;
+
+	eap = radius_msg_get_eap(msg);
+	if (eap == NULL) {
+		/* draft-aboba-radius-rfc2869bis-20.txt, Chap. 2.6.3:
+		 * RADIUS server SHOULD NOT send Access-Reject/no EAP-Message
+		 * attribute */
+		wpa_printf(MSG_DEBUG, "could not extract "
+			       "EAP-Message from RADIUS message");
+		wpabuf_free(e->last_eap_radius);
+		e->last_eap_radius = NULL;
+		return;
+	}
+
+	if (wpabuf_len(eap) < sizeof(*hdr)) {
+		wpa_printf(MSG_DEBUG, "too short EAP packet "
+			       "received from authentication server");
+		wpabuf_free(eap);
+		return;
+	}
+
+	if (wpabuf_len(eap) > sizeof(*hdr))
+		eap_type = (wpabuf_head_u8(eap))[sizeof(*hdr)];
+
+	hdr = wpabuf_head(eap);
+	switch (hdr->code) {
+	case EAP_CODE_REQUEST:
+		os_snprintf(buf, sizeof(buf), "EAP-Request-%s (%d)",
+			    eap_type >= 0 ? eap_type_text(eap_type) : "??",
+			    eap_type);
+		break;
+	case EAP_CODE_RESPONSE:
+		os_snprintf(buf, sizeof(buf), "EAP Response-%s (%d)",
+			    eap_type >= 0 ? eap_type_text(eap_type) : "??",
+			    eap_type);
+		break;
+	case EAP_CODE_SUCCESS:
+		os_strlcpy(buf, "EAP Success", sizeof(buf));
+		/* LEAP uses EAP Success within an authentication, so must not
+		 * stop here with eloop_terminate(); */
+		break;
+	case EAP_CODE_FAILURE:
+		os_strlcpy(buf, "EAP Failure", sizeof(buf));
+		eloop_terminate();
+		break;
+	default:
+		os_strlcpy(buf, "unknown EAP code", sizeof(buf));
+		wpa_hexdump_buf(MSG_DEBUG, "Decapsulated EAP packet", eap);
+		break;
+	}
+	wpa_printf(MSG_DEBUG, "decapsulated EAP packet (code=%d "
+		       "id=%d len=%d) from RADIUS server: %s",
+		      hdr->code, hdr->identifier, ntohs(hdr->length), buf);
+
+	/* sta->eapol_sm->be_auth.idFromServer = hdr->identifier; */
+
+	wpabuf_free(e->last_eap_radius);
+	e->last_eap_radius = eap;
+
+	{
+		struct ieee802_1x_hdr *dot1x;
+		dot1x = os_malloc(sizeof(*dot1x) + wpabuf_len(eap));
+		assert(dot1x != NULL);
+		dot1x->version = EAPOL_VERSION;
+		dot1x->type = IEEE802_1X_TYPE_EAP_PACKET;
+		dot1x->length = htons(wpabuf_len(eap));
+		os_memcpy((u8 *) (dot1x + 1), wpabuf_head(eap),
+			  wpabuf_len(eap));
+		eapol_sm_rx_eapol(e->wpa_s->eapol, e->wpa_s->bssid,
+				  (u8 *) dot1x,
+				  sizeof(*dot1x) + wpabuf_len(eap));
+		os_free(dot1x);
+	}
+}
+
+
+static void ieee802_1x_get_keys(struct radeapclient_data_t *e,
+				struct radius_msg *msg, struct radius_msg *req,
+				const u8 *shared_secret,
+				size_t shared_secret_len)
+{
+	struct radius_ms_mppe_keys *keys;
+
+	keys = radius_msg_get_ms_keys(msg, req, shared_secret,
+				      shared_secret_len);
+	if (keys && keys->send == NULL && keys->recv == NULL) {
+		os_free(keys);
+		keys = radius_msg_get_cisco_keys(msg, req, shared_secret,
+						 shared_secret_len);
+	}
+
+	if (keys) {
+		if (keys->send) {
+			wpa_hexdump(MSG_DEBUG, "MS-MPPE-Send-Key (sign)",
+				    keys->send, keys->send_len);
+		}
+		if (keys->recv) {
+			wpa_hexdump(MSG_DEBUG, "MS-MPPE-Recv-Key (crypt)",
+				    keys->recv, keys->recv_len);
+			e->authenticator_pmk_len =
+				keys->recv_len > PMK_LEN ? PMK_LEN :
+				keys->recv_len;
+			os_memcpy(e->authenticator_pmk, keys->recv,
+				  e->authenticator_pmk_len);
+			if (e->authenticator_pmk_len == 16 && keys->send &&
+			    keys->send_len == 16) {
+				/* MS-CHAP-v2 derives 16 octet keys */
+				wpa_printf(MSG_DEBUG, "Use MS-MPPE-Send-Key "
+					   "to extend PMK to 32 octets");
+				os_memcpy(e->authenticator_pmk +
+					  e->authenticator_pmk_len,
+					  keys->send, keys->send_len);
+				e->authenticator_pmk_len += keys->send_len;
+			}
+		}
+
+		os_free(keys->send);
+		os_free(keys->recv);
+		os_free(keys);
+	}
+}
+
+
+/* Process the RADIUS frames from Authentication Server */
+static RadiusRxResult
+ieee802_1x_receive_auth(struct radius_msg *msg, struct radius_msg *req,
+			const u8 *shared_secret, size_t shared_secret_len,
+			void *data)
+{
+	struct radeapclient_data_t *e = data;
+	struct radius_hdr *hdr = radius_msg_get_hdr(msg);
+
+	/* RFC 2869, Ch. 5.13: valid Message-Authenticator attribute MUST be
+	 * present when packet contains an EAP-Message attribute */
+	if (hdr->code == RADIUS_CODE_ACCESS_REJECT &&
+	    radius_msg_get_attr(msg, RADIUS_ATTR_MESSAGE_AUTHENTICATOR, NULL,
+				0) < 0 &&
+	    radius_msg_get_attr(msg, RADIUS_ATTR_EAP_MESSAGE, NULL, 0) < 0) {
+		wpa_printf(MSG_DEBUG, "Allowing RADIUS "
+			      "Access-Reject without Message-Authenticator "
+			      "since it does not include EAP-Message");
+	} else if (radius_msg_verify(msg, shared_secret, shared_secret_len,
+				     req, 1)) {
+		wpa_printf(MSG_WARNING, "Incoming RADIUS packet did not have correct "
+		       "Message-Authenticator - dropped");
+		return RADIUS_RX_UNKNOWN;
+	}
+
+	if (hdr->code != RADIUS_CODE_ACCESS_ACCEPT &&
+	    hdr->code != RADIUS_CODE_ACCESS_REJECT &&
+	    hdr->code != RADIUS_CODE_ACCESS_CHALLENGE) {
+		wpa_printf(MSG_WARNING, "Unknown RADIUS message code");
+		return RADIUS_RX_UNKNOWN;
+	}
+
+	e->radius_identifier = -1;
+	wpa_printf(MSG_DEBUG, "RADIUS packet matching with station");
+
+	radius_msg_free(e->last_recv_radius);
+	e->last_recv_radius = msg;
+
+	switch (hdr->code) {
+	case RADIUS_CODE_ACCESS_ACCEPT:
+		e->radius_access_accept_received = 1;
+		ieee802_1x_get_keys(e, msg, req, shared_secret,
+				    shared_secret_len);
+		break;
+	case RADIUS_CODE_ACCESS_REJECT:
+		e->radius_access_reject_received = 1;
+		break;
+	}
+
+	ieee802_1x_decapsulate_radius(e);
+
+	if ((hdr->code == RADIUS_CODE_ACCESS_ACCEPT &&
+	     e->radeapclient_num_reauths < 0) ||
+	    hdr->code == RADIUS_CODE_ACCESS_REJECT) {
+		eloop_terminate();
+	}
+
+	return RADIUS_RX_QUEUED;
+}
+
+
+static int wpa_init_conf(struct radeapclient_data_t *e,
+			  struct wpa_supplicant *wpa_s, const char *authsrv_ip,
+			  int port, const char *secret)
+{
+	struct hostapd_radius_server *as;
+	int res;
+
+	wpa_s->bssid[5] = 1;
+	os_memcpy(wpa_s->own_addr, e->own_addr, ETH_ALEN);
+	e->own_ip_addr.s_addr = htonl((127 << 24) | 1);
+	os_strlcpy(wpa_s->ifname, "test", sizeof(wpa_s->ifname));
+
+	e->radius_conf = os_zalloc(sizeof(struct hostapd_radius_servers));
+	assert(e->radius_conf != NULL);
+	e->radius_conf->num_auth_servers = 1;
+	as = os_zalloc(sizeof(struct hostapd_radius_server));
+	assert(as != NULL);
+
+    if (hostapd_parse_ip_addr(authsrv_ip,  &as->addr) != 0)
+    {
+        wpa_printf(MSG_ERROR, "Invalid authentication server IP address '%s'", authsrv_ip);
+        return -1;
+    }
+
+	as->port = port;
+	as->shared_secret = (u8 *) os_strdup(secret);
+	as->shared_secret_len = os_strlen(secret);
+	e->radius_conf->auth_server = as;
+	e->radius_conf->auth_servers = as;
+	e->radius_conf->msg_dumps = 1;
+
+	e->radius = radius_client_init(wpa_s, e->radius_conf);
+	if (!e->radius)
+    {
+        wpa_printf(MSG_ERROR, "Invalid initializing RADIUS client");
+        return -1;
+    }
+	res = radius_client_register(e->radius, RADIUS_AUTH,
+				     ieee802_1x_receive_auth, e);
+
+    if (res != 0)
+    {
+        wpa_printf(MSG_ERROR, "Invalid registering RADIUS client callback");
+        return -1;
+    }
+    return 0;
+}
+
+
+static void radeapclient_terminate(int sig, void *signal_ctx)
+{
+	struct wpa_supplicant *wpa_s = signal_ctx;
+	wpa_msg(wpa_s, MSG_INFO, "Signal %d received - terminating", sig);
+	eloop_terminate();
+}
+
+
+static void usage(void)
+{
+	printf("usage:\n"
+	       "%s [-nWS] -c<conf> [-a<AS IP>] [-p<AS port>] "
+	       "[-s<AS secret>]\\\n"
+	       "           [-r<count>] [-t<timeout>] [-C<Connect-Info>] \\\n"
+	       "           [-M<client MAC address>] [-o<server cert file] \\\n"
+	       "           [-N<attr spec>] \\\n"
+	       "           [-P<client port>]\\\n"
+	       "           [-v<verbosity>]\n"
+	       "\n", rad_eap_client_prog_name);
+	printf("options:\n"
+	       "  -c<conf> = configuration file\n"
+	       "  -a<AS IP> = IPv4 or IPv6 address of the authentication server, "
+	       "default 127.0.0.1\n"
+	       "  -p<AS port> = UDP port of the authentication server, "
+	       "default 1812\n"
+	       "  -s<AS secret> = shared secret with the authentication "
+	       "server, default 'radius'\n"
+           "-p<client port> = port of the client\n"
+	       "  -r<count> = number of re-authentications\n"
+	       "  -W = wait for a control interface monitor before starting\n"
+	       "  -S = save configuration after authentication\n"
+	       "  -n = no MPPE keys expected\n"
+	       "  -t<timeout> = sets timeout in seconds (default: 30 s)\n"
+	       "  -C<Connect-Info> = RADIUS Connect-Info (default: "
+	       "CONNECT 11Mbps 802.11b)\n"
+	       "  -M<client MAC address> = Set own MAC address "
+	       "(Calling-Station-Id,\n"
+	       "                           default: 02:00:00:00:00:01)\n"
+	       "  -o<server cert file> = Write received server certificate\n"
+	       "                         chain to the specified file\n"
+	       "  -N<attr spec> = send arbitrary attribute specified by:\n"
+	       "                  attr_id:syntax:value or attr_id\n"
+	       "                  attr_id - number id of the attribute\n"
+	       "                  syntax - one of: s, d, x\n"
+	       "                     s = string\n"
+	       "                     d = integer\n"
+	       "                     x = octet string\n"
+	       "                  value - attribute value.\n"
+	       "       When only attr_id is specified, NULL will be used as "
+	       "value.\n"
+	       "       Multiple attributes can be specified by using the "
+	       "option several times.\n"
+            "  -v<verbosity level> = set verbosity level. One of debug, info, warn, error.\n"
+            "  Default: info.\n");
+}
+
+
+int main(int argc, char *argv[])
+{
+	struct wpa_supplicant wpa_s;
+	int c, ret = 1, wait_for_monitor = 0, save_config = 0;
+	char *as_ip_addr = "127.0.0.1";
+	int as_port = 1812;
+	char *as_secret = "radius";
+    int caller_port = 0;
+	char *conf = NULL;
+	int timeout = 30;
+	char *pos;
+	struct extra_radius_attr *p = NULL, *p1;
+
+	if (os_program_init())
+		return rad_eap_client_exit_code_default_error;
+
+	hostapd_logger_register_cb(hostapd_logger_cb);
+
+	os_memset(&radeapclient_data, 0, sizeof(radeapclient_data));
+	radeapclient_data.connect_info = "CONNECT 11Mbps 802.11b";
+	os_memcpy(radeapclient_data.own_addr, "\x02\x00\x00\x00\x00\x01", ETH_ALEN);
+
+	wpa_debug_level = MSG_INFO;
+	wpa_debug_show_keys = 0;
+	wpa_debug_timestamp = 1;
+
+	for (;;) {
+		c = getopt(argc, argv, "a:A:c:C:M:nN:o:p:P:r:s:St:W:v:");
+		if (c < 0)
+			break;
+		switch (c) {
+		case 'a':
+			as_ip_addr = optarg;
+			break;
+		case 'c':
+			conf = optarg;
+			break;
+		case 'C':
+			radeapclient_data.connect_info = optarg;
+			break;
+		case 'M':
+			if (hwaddr_aton(optarg, radeapclient_data.own_addr)) {
+				usage();
+				return rad_eap_client_exit_code_default_error;
+			}
+			break;
+		case 'n':
+			radeapclient_data.no_mppe_keys++;
+			break;
+		case 'o':
+			if (radeapclient_data.server_cert_file)
+				fclose(radeapclient_data.server_cert_file);
+			radeapclient_data.server_cert_file = fopen(optarg, "w");
+			if (radeapclient_data.server_cert_file == NULL) {
+				wpa_printf(MSG_ERROR, "Could not open '%s' for writing",
+				       optarg);
+				return rad_eap_client_exit_code_default_error;
+			}
+			break;
+		case 'p':
+			as_port = atoi(optarg);
+			break;
+        case 'P':
+            caller_port = atoi(optarg);
+            break;
+		case 'r':
+			radeapclient_data.radeapclient_num_reauths = atoi(optarg);
+			break;
+		case 's':
+			as_secret = optarg;
+			break;
+		case 'S':
+			save_config++;
+			break;
+		case 't':
+			timeout = atoi(optarg);
+			break;
+		case 'W':
+			wait_for_monitor++;
+			break;
+		case 'N':
+			p1 = os_zalloc(sizeof(*p1));
+			if (p1 == NULL)
+				break;
+			if (!p)
+				radeapclient_data.extra_attrs = p1;
+			else
+				p->next = p1;
+			p = p1;
+
+			p->type = atoi(optarg);
+			pos = os_strchr(optarg, ':');
+			if (pos == NULL) {
+				p->syntax = 'n';
+				p->data = NULL;
+				break;
+			}
+
+			pos++;
+			if (pos[0] == '\0' || pos[1] != ':') {
+				wpa_printf(MSG_ERROR, "Incorrect format of attribute "
+				       "specification");
+				break;
+			}
+
+			p->syntax = pos[0];
+			p->data = pos + 2;
+			break;
+        case 'v':
+            if (optarg)
+            {
+                if (strcasecmp(optarg, "debug") == 0)
+                {
+                    wpa_debug_level = MSG_DEBUG;
+                    wpa_debug_show_keys = 1;
+                }
+                else if (strcasecmp(optarg, "info") == 0)
+                {
+                    wpa_debug_level = MSG_INFO;
+                    wpa_debug_show_keys = 0;
+                }
+                else if (strcasecmp(optarg, "warn") == 0 || strcasecmp(optarg, "warning") == 0)
+                {
+                    wpa_debug_level = MSG_WARNING;
+                    wpa_debug_show_keys = 0;
+                }
+                else if (strcasecmp(optarg, "error") == 0)
+                {
+                    wpa_debug_level = MSG_ERROR;
+                    wpa_debug_show_keys = 0;
+                }
+            }
+            break;
+        default:
+            usage();
+            return rad_eap_client_exit_code_default_error;
+        }
+    }
+
+    int caller_sockfd = -1;
+    if (caller_port != 0)
+    {
+        if (init_caller_connection(caller_port, &caller_sockfd))
+        {
+            return rad_eap_client_exit_code_default_error;
+        }
+    }
+
+	if (conf == NULL) {
+		usage();
+		wpa_printf(MSG_ERROR, "Configuration file is required.");
+		return rad_eap_client_exit_code_default_error;
+	}
+
+	if (eap_register_methods()) {
+		wpa_printf(MSG_ERROR, "Failed to register EAP methods");
+		return rad_eap_client_exit_code_default_error;
+	}
+
+	if (eloop_init()) {
+		wpa_printf(MSG_ERROR, "Failed to initialize event loop");
+		return rad_eap_client_exit_code_default_error;
+	}
+
+	os_memset(&wpa_s, 0, sizeof(wpa_s));
+	radeapclient_data.wpa_s = &wpa_s;
+	wpa_s.conf = wpa_config_read(conf);
+	if (wpa_s.conf == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to parse configuration file '%s'.", conf);
+		return rad_eap_client_exit_code_default_error;
+	}
+	if (wpa_s.conf->ssid == NULL) {
+		wpa_printf(MSG_ERROR, "No networks defined.");
+		return rad_eap_client_exit_code_default_error;
+	}
+
+	if (wpa_init_conf(&radeapclient_data, &wpa_s, as_ip_addr, as_port, as_secret))
+    {
+        wpa_printf(MSG_ERROR, "Failed to initialize configuration");
+        return rad_eap_client_exit_code_default_error;
+    }
+	wpa_s.ctrl_iface = wpa_supplicant_ctrl_iface_init(&wpa_s);
+	if (wpa_s.ctrl_iface == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to initialize control interface '%s'.\n"
+		       "You may have another radeapclient process already "
+		       "running or the file was\n"
+		       "left by an unclean termination of radeapclient in "
+		       "which case you will need\n"
+		       "to manually remove this file before starting "
+		       "radeapclient again.",
+		       wpa_s.conf->ctrl_interface);
+		return rad_eap_client_exit_code_default_error;
+	}
+    wpa_s.caller_sockfd = caller_sockfd;
+    wpa_s.challenge_code = rad_eap_client_msg_code_challenge;
+
+	if (wpa_supplicant_scard_init(&wpa_s, wpa_s.conf->ssid))
+		return rad_eap_client_exit_code_default_error;
+
+	if (test_eapol(&radeapclient_data, &wpa_s, wpa_s.conf->ssid))
+		return rad_eap_client_exit_code_default_error;
+
+	if (wpas_init_ext_pw(&wpa_s) < 0)
+		return rad_eap_client_exit_code_default_error;
+
+	if (wait_for_monitor)
+		wpa_supplicant_ctrl_iface_wait(wpa_s.ctrl_iface);
+
+	eloop_register_timeout(timeout, 0, radeapclient_timeout, &radeapclient_data,
+			       NULL);
+	eloop_register_timeout(0, 0, send_eap_request_identity, &wpa_s, NULL);
+	eloop_register_signal_terminate(radeapclient_terminate, &wpa_s);
+	eloop_register_signal_reconfig(radeapclient_terminate, &wpa_s);
+
+    //
+    // do the job
+    //
+	eloop_run();
+
+	eloop_cancel_timeout(radeapclient_timeout, &radeapclient_data, NULL);
+	eloop_cancel_timeout(eapol_sm_reauth, &radeapclient_data, NULL);
+
+	if (radeapclient_compare_pmk(&radeapclient_data) == 0 ||
+	    radeapclient_data.no_mppe_keys)
+		ret = rad_eap_client_exit_code_auth_ok;
+	if (radeapclient_data.auth_timed_out)
+		ret = rad_eap_client_exit_code_radius_svr_connection_error;
+	if (radeapclient_data.radius_access_reject_received)
+		ret = rad_eap_client_exit_code_auth_nok;
+
+	if (save_config)
+		wpa_config_write(conf, wpa_s.conf);
+
+	test_eapol_clean(&radeapclient_data, &wpa_s);
+
+	eap_peer_unregister_methods();
+#ifdef CONFIG_AP
+	eap_server_unregister_methods();
+#endif /* CONFIG_AP */
+
+	eloop_destroy();
+
+	if (radeapclient_data.server_cert_file)
+		fclose(radeapclient_data.server_cert_file);
+
+	wpa_printf(MSG_INFO, "MPPE keys OK: %d  mismatch: %d",
+	       radeapclient_data.num_mppe_ok, radeapclient_data.num_mppe_mismatch);
+	if (radeapclient_data.num_mppe_mismatch)
+		ret = rad_eap_client_exit_code_default_error;
+
+    wpa_printf(MSG_INFO, "Finished with result: %s", ret == rad_eap_client_exit_code_auth_ok ? "AUTHENTICATION SUCCESSFUL"
+                                        : ret == rad_eap_client_exit_code_auth_nok ? "AUTHENTICATION NOT SUCCESSFUL"
+                                        : ret == rad_eap_client_exit_code_radius_svr_connection_error ? "CONNECTION ERROR OR TIMEOUT"
+                                        : "ERROR");
+
+
+    // notify caller on exit reason if we are connected to it
+    notify_caller(caller_sockfd, ret);
+    os_program_deinit();
+
+	return ret;
+}
diff -ruN wpa_supplicant/radeapclient.conf wpa_supplicant/radeapclient.conf
--- wpa_supplicant/radeapclient.conf	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant/radeapclient.conf	2016-07-19 10:33:25.507639086 +0200
@@ -0,0 +1,8 @@
+network={
+    # eap=<list-of-eap-methods> when specified is used to negotiate EAP method with authenticator.
+	identity="DemoUser"
+	password="secret"
+	#ca_cert="/keytalk/Software/Server/Projects/config/radius/certs/ca.pem"
+	#client_cert="/keytalk/Software/Server/Projects/config/radius/certs/client.pem"
+	#private_key="/keytalk/Software/Server/Projects/config/radius/certs/client.pem"
+}
diff -ruN wpa_supplicant/radeapclient.h wpa_supplicant/radeapclient.h
--- wpa_supplicant/radeapclient.h	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant/radeapclient.h	2016-07-19 08:27:52.310681222 +0200
@@ -0,0 +1,23 @@
+#ifndef RADEAPCLIENT_H
+#define RADEAPCLIENT_H
+
+#include <stdint.h>
+
+static const char* rad_eap_client_prog_name = "radeapclient";
+static const char* rad_eap_client_connect_ipv4 = "127.0.0.1";
+
+enum rad_eap_client_exit_code
+{
+    rad_eap_client_exit_code_auth_ok = 0,
+    rad_eap_client_exit_code_auth_nok,
+    rad_eap_client_exit_code_radius_svr_connection_error = 10, // error connecting to RADUIS server (invalid IP/port or secret)
+    rad_eap_client_exit_code_default_error = 100
+};
+
+static const int32_t rad_eap_client_msg_code_auth_ok = 0;
+static const int32_t rad_eap_client_msg_code_auth_nok = 1;
+static const int32_t rad_eap_client_msg_code_challenge = 2;
+static const int32_t rad_eap_client_msg_code_radius_svr_connection_error = 10;
+static const int32_t rad_eap_client_msg_code_default_error = 100;
+
+#endif //RADEAPCLIENT_H
diff -ruN wpa_supplicant/radeapclient-sim.conf wpa_supplicant/radeapclient-sim.conf
--- wpa_supplicant/radeapclient-sim.conf	1970-01-01 01:00:00.000000000 +0100
+++ wpa_supplicant/radeapclient-sim.conf	2016-07-19 08:27:52.310681222 +0200
@@ -0,0 +1,8 @@
+# EAP-SIM with a GSM SIM or USIM
+network={
+	ssid="eap-sim-test"
+	key_mgmt=WPA-EAP
+	eap=SIM
+	pin="1234"
+	pcsc=""
+}
diff -ruN wpa_supplicant/scan.c wpa_supplicant/scan.c
--- wpa_supplicant/scan.c	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/scan.c	2016-07-19 08:27:52.310681222 +0200
@@ -1289,7 +1289,9 @@
 static int wpa_scan_result_compar(const void *a, const void *b)
 {
 #define IS_5GHZ(n) (n > 4000)
+#ifndef MIN
 #define MIN(a,b) a < b ? a : b
+#endif
 	struct wpa_scan_res **_wa = (void *) a;
 	struct wpa_scan_res **_wb = (void *) b;
 	struct wpa_scan_res *wa = *_wa;
diff -ruN wpa_supplicant/wpa_supplicant.c wpa_supplicant/wpa_supplicant.c
--- wpa_supplicant/wpa_supplicant.c	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/wpa_supplicant.c	2016-07-19 08:27:52.390684597 +0200
@@ -2667,8 +2667,9 @@

 	if (!wpa_s->conf->pcsc_reader)
 		return 0;
-
+#ifndef PCSC_RELAY_FUNCS
 	wpa_s->scard = scard_init(SCARD_TRY_BOTH, wpa_s->conf->pcsc_reader);
+#endif
 	if (!wpa_s->scard)
 		return 1;

diff -ruN wpa_supplicant/wpa_supplicant_i.h wpa_supplicant/wpa_supplicant_i.h
--- wpa_supplicant/wpa_supplicant_i.h	2013-01-12 16:42:53.000000000 +0100
+++ wpa_supplicant/wpa_supplicant_i.h	2016-07-19 08:27:52.406685228 +0200
@@ -390,6 +390,10 @@

 	struct scard_data *scard;
 #ifdef PCSC_FUNCS
+#ifdef PCSC_RELAY_FUNCS
+    int caller_sockfd;
+    int32_t challenge_code;
+#endif
 	char imsi[20];
 	int mnc_len;
 #endif /* PCSC_FUNCS */
